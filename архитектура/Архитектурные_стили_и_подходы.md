# Архитектурные стили и подходы — подробный конспект

Этот конспект сделан по пункту из файла `Список тяжелых навыков - Степан.xlsx` → **Проектирование** → **Архитектурные стили**:

- Луковая архитектура / Чистая архитектура / Гексагональная архитектура / Архитектура портов и адаптеров
- Конвейерная архитектура / Архитектура каналов и фильтров (pipes and filters)
- Событийно-ориентированная архитектура
- Архитектура на основе сервисов
- Микросервисная архитектура

Цель: понимать **когда какой стиль выбирать**, **какие проблемы решает**, **какие компромиссы**, **как применять на практике**.

## Общая рамка: что такое архитектурный стиль

Архитектурный стиль — это **набор принципов организации системы**, которые определяют:
- Как компоненты взаимодействуют
- Как данные передаются
- Какие ограничения и правила действуют
- Какие проблемы решаются

Важно: стили можно комбинировать. Например, микросервисы могут использовать событийную архитектуру внутри.

## 1) Чистая архитектура и родственные подходы

### 1.1 Общая идея

Группа архитектурных стилей, которые разделяют систему на **слои с четкими зависимостями**: внешние слои зависят от внутренних, но не наоборот. Бизнес-логика изолирована от деталей реализации (БД, UI, фреймворки).

### 1.2 Гексагональная архитектура (Hexagonal Architecture / Ports and Adapters)

**Что это**

Архитектура, где приложение представлено как **шестиугольник** (гексагон), внутри которого — бизнес-логика, а снаружи — адаптеры для взаимодействия с внешним миром.

**Ключевые понятия**

- **Порты (Ports)**: интерфейсы, которые определяют, как приложение взаимодействует с внешним миром
  - Входящие порты (primary/driving): что приложение **предоставляет** (например, REST API, CLI)
  - Исходящие порты (secondary/driven): что приложение **использует** (например, БД, внешние сервисы)
- **Адаптеры (Adapters)**: конкретные реализации портов
  - Входящие адаптеры: контроллеры, обработчики HTTP, CLI-парсеры
  - Исходящие адаптеры: репозитории для БД, клиенты внешних API, файловые системы

**Структура зависимостей**

```
Внешний мир → Адаптеры → Порты → Доменная логика
```

Доменная логика **не знает** про HTTP, SQL, файлы. Она знает только про интерфейсы (порты).

**Примеры**

- Входящий порт: `interface OrderService { createOrder(order: Order): Promise<OrderId> }`
- Входящий адаптер: REST контроллер, который вызывает `OrderService`
- Исходящий порт: `interface OrderRepository { save(order: Order): Promise<void> }`
- Исходящий адаптер: PostgreSQL-реализация `OrderRepository`

**Короткий пример на Python (порты и адаптеры)**

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class Order:
    id: str
    total: float

class OrderRepositoryPort(ABC):
    @abstractmethod
    def save(self, order: Order) -> None: ...

class InMemoryOrderRepository(OrderRepositoryPort):
    def __init__(self):
        self._orders: list[Order] = []

    def save(self, order: Order) -> None:
        self._orders.append(order)

class CreateOrderUseCase:
    def __init__(self, repository: OrderRepositoryPort):
        self._repo = repository

    def execute(self, order_id: str, total: float) -> Order:
        order = Order(id=order_id, total=total)
        self._repo.save(order)
        return order

class CliOrderDriver:
    def __init__(self, use_case: CreateOrderUseCase):
        self._use_case = use_case

    def run(self, order_id: str, total: float) -> Order:
        return self._use_case.execute(order_id, total)

outgoing_adapter = InMemoryOrderRepository()
use_case = CreateOrderUseCase(outgoing_adapter)
incoming_adapter = CliOrderDriver(use_case)
order = incoming_adapter.run("ord-1", 99.99)
```
- **Входящий порт** — контракт «как приложение принимает команды». В примере это роль use case: у него метод `execute(order_id, total)`. Можно оформить как отдельный интерфейс (ABC) с методом `execute`, который реализует `CreateOrderUseCase`.
- **Исходящий порт** — `OrderRepositoryPort`: интерфейс (ABC) с методом `save`. Ядро зависит от него, а не от конкретной БД.
- **Входящий адаптер** — `CliOrderDriver`: переводит вызов из внешнего мира (CLI) в вызов use case.
- **Исходящий адаптер** — `InMemoryOrderRepository`: реализует порт `OrderRepositoryPort`, подменяема на PostgreSQL и т.д.

**Когда подходит**

- Нужна независимость от фреймворков и библиотек
- Планируются разные способы взаимодействия (REST, GraphQL, CLI, gRPC)
- Нужно легко тестировать бизнес-логику без БД/сети
- Команда хочет четко разделить ответственность

**Когда не подходит**

- Очень простые CRUD-приложения без сложной логики
- Прототипы и MVP, где скорость важнее структуры
- Команда не готова поддерживать абстракции

### 1.3 Чистая архитектура (Clean Architecture)

**Что это**

Подход Роберта Мартина, который расширяет идеи гексагональной архитектуры, добавляя **четкие слои с правилом зависимостей**.

**Слои (от внешнего к внутреннему)**

1. **Frameworks & Drivers**: UI, веб-фреймворки, БД, внешние библиотеки
2. **Interface Adapters**: контроллеры, презентеры, шлюзы (репозитории)
3. **Use Cases / Application**: бизнес-сценарии, оркестрация
4. **Entities / Domain**: бизнес-сущности и правила домена

**Правило зависимостей**

Зависимости направлены **внутрь**: внешние слои зависят от внутренних, внутренние не зависят от внешних.

**Пример структуры**

```
/api (Frameworks)
  /controllers (Interface Adapters)
    OrderController → вызывает
/application (Use Cases)
  /use-cases
    CreateOrderUseCase → использует
/domain (Entities)
  /entities
    Order, OrderItem
  /repositories (интерфейсы)
    IOrderRepository
/infrastructure (Frameworks)
  /repositories (реализации)
    PostgresOrderRepository implements IOrderRepository
```

**Когда подходит**

- Большие долгоживущие проекты
- Нужна максимальная гибкость: замена БД, UI, фреймворков
- Команда готова инвестировать в структуру

**Когда не подходит**

- Маленькие проекты, где overhead структуры не оправдан
- Команда не понимает принципы и будет нарушать правила

### 1.4 Луковая архитектура (Onion Architecture)

**Что это**

Вариант чистой архитектуры, где слои представлены как **концентрические круги** (как луковица).

**Слои (от центра к краю)**

1. **Domain Model** (центр): сущности и интерфейсы репозиториев
2. **Domain Services**: бизнес-логика, которая не принадлежит одной сущности
3. **Application Services**: use cases, оркестрация
4. **Infrastructure / UI**: реализации репозиториев, контроллеры, внешние сервисы

**Ключевое отличие от чистой архитектуры**

В луковой архитектуре **инфраструктура зависит от домена**, а не наоборот. Домен определяет интерфейсы, инфраструктура их реализует.

**Когда подходит**

- DDD (Domain-Driven Design) проекты
- Когда доменная модель — главная ценность
- Нужна четкая изоляция домена

### 1.5 Сравнение и выбор

| Критерий | Гексагональная | Чистая | Луковая |
|---|---|---|---|
| Фокус | Порты и адаптеры | Слои и зависимости | Домен в центре |
| Сложность | Средняя | Высокая | Высокая |
| Подходит для | Средние проекты | Большие проекты | DDD проекты |
| Тестируемость | Высокая | Очень высокая | Очень высокая |

**Практический совет**

Для большинства проектов достаточно **гексагональной архитектуры** с разделением на:
- Домен (entities, value objects, domain services)
- Приложение (use cases, application services)
- Инфраструктура (репозитории, контроллеры, внешние клиенты)

## 2) Конвейерная архитектура (Pipes and Filters)

**Что это**

Архитектура, где данные обрабатываются через **цепочку независимых фильтров**, соединенных **каналами** (pipes).

**Ключевые компоненты**

- **Фильтры (Filters)**: независимые компоненты, которые обрабатывают данные
  - Могут быть stateless или stateful
  - Принимают входные данные, обрабатывают, возвращают результат
- **Каналы (Pipes)**: передают данные между фильтрами
  - Обычно однонаправленные
  - Могут буферизовать данные

**Типы фильтров**

- **Producer**: источник данных (читает файл, принимает запрос)
- **Transformer**: преобразует данные (парсинг, валидация, форматирование)
- **Tester**: проверяет условие, пропускает или блокирует
- **Consumer**: конечный получатель (сохраняет, отправляет)

**Примеры**

- Компиляторы: лексический анализ → парсинг → оптимизация → генерация кода
- ETL-процессы: извлечение → трансформация → загрузка
- Обработка изображений: загрузка → ресайз → фильтр → сохранение
- Unix pipelines: `cat file.txt | grep "error" | sort | uniq`

**Преимущества**

- **Модульность**: каждый фильтр независим, легко тестировать
- **Параллелизм**: фильтры могут работать параллельно
- **Гибкость**: легко добавлять/удалять/переставлять фильтры
- **Повторное использование**: фильтры можно комбинировать по-разному

**Недостатки**

- Не подходит для интерактивных систем (нужна обратная связь)
- Сложно обрабатывать ошибки в середине цепочки
- Может быть overhead на передачу данных между фильтрами

**Когда подходит**

- Обработка данных в пакетном режиме
- Трансформации данных (ETL, конвейеры данных)
- Компиляторы и интерпретаторы
- Обработка потоков событий (с модификациями)

**Когда не подходит**

- Интерактивные приложения с UI
- Системы, где нужна сложная координация между компонентами
- Когда производительность критична и overhead передачи данных недопустим

**Практический пример**

```python
def read_file(path: str) -> Iterator[str]:
    with open(path) as f:
        yield from f

def filter_errors(lines: Iterator[str]) -> Iterator[str]:
    return (line for line in lines if "error" in line.lower())

def uppercase(lines: Iterator[str]) -> Iterator[str]:
    return (line.upper() for line in lines)

def write_file(lines: Iterator[str], path: str):
    with open(path, 'w') as f:
        f.writelines(lines)

pipeline = read_file("log.txt") | filter_errors | uppercase | write_file("errors.txt")
```

## 3) Событийно-ориентированная архитектура (Event-Driven Architecture, EDA)

**Что это**

Архитектура, где компоненты взаимодействуют через **события**: один компонент публикует событие, другие подписываются и реагируют.

**Ключевые понятия**

- **Событие (Event)**: факт, что что-то произошло (immutable, прошлое время: "OrderCreated", "PaymentProcessed")
- **Издатель (Publisher/Producer)**: компонент, который публикует события
- **Подписчик (Subscriber/Consumer)**: компонент, который обрабатывает события
- **Брокер событий (Event Broker)**: промежуточный слой (очередь, шина событий), который доставляет события

**Модели взаимодействия**

1. **Pub/Sub (Publish-Subscribe)**: издатель не знает, кто подписан. Брокер доставляет событие всем подписчикам.
2. **Event Streaming**: события хранятся в логе, подписчики читают с нужной позиции (Kafka, EventStore).
3. **Event Sourcing**: состояние системы восстанавливается из потока событий.

**Преимущества**

- **Слабая связанность**: компоненты не знают друг о друге напрямую
- **Масштабируемость**: подписчики могут масштабироваться независимо
- **Гибкость**: легко добавлять новых подписчиков без изменения издателей
- **Асинхронность**: обработка может быть отложенной
- **Аудит**: события — это история изменений

**Недостатки**

- **Сложность отладки**: поток событий может быть неочевидным
- **Согласованность**: сложнее обеспечить транзакционность между компонентами
- **Порядок событий**: нужно учитывать порядок и дубликаты
- **Тестирование**: сложнее тестировать распределенные сценарии

**Когда подходит**

- Микросервисы, которым нужно слабое связывание
- Системы, где компоненты должны реагировать на изменения независимо
- Нужна история изменений (аудит, аналитика)
- Асинхронная обработка (уведомления, интеграции)

**Когда не подходит**

- Простые CRUD-приложения без сложных интеграций
- Когда нужна строгая транзакционность между операциями
- Команда не готова работать с асинхронностью и eventual consistency

**Практические паттерны**

- **Event Sourcing**: храним события, состояние вычисляем
- **CQRS**: разделение на команды (write) и запросы (read), синхронизация через события
- **Saga**: распределенные транзакции через цепочку событий

**Примеры событий**

- `OrderCreated(orderId, customerId, items)`
- `PaymentProcessed(orderId, amount, method)`
- `InventoryReserved(orderId, items)`
- `OrderShipped(orderId, trackingNumber)`

## 4) Архитектура на основе сервисов (Service-Oriented Architecture, SOA)

**Что это**

Архитектурный стиль, где функциональность организована как **набор сервисов**, которые взаимодействуют через стандартизированные интерфейсы.

**Ключевые принципы**

- **Сервисы**: автономные, переиспользуемые компоненты с четким интерфейсом
- **Слабая связанность**: сервисы взаимодействуют через контракты, не знают детали реализации друг друга
- **Стандартизация**: общие протоколы (SOAP, REST), форматы данных (XML, JSON), паттерны взаимодействия
- **Композиция**: сложная функциональность собирается из сервисов

**Компоненты SOA**

- **Service Provider**: предоставляет сервис
- **Service Consumer**: использует сервис
- **Service Registry**: каталог сервисов (опционально, для discovery)
- **Service Bus / ESB**: промежуточный слой для маршрутизации, трансформации, оркестрации

**Типы сервисов**

- **Business Services**: бизнес-функциональность (OrderService, PaymentService)
- **Application Services**: технические сервисы (AuthenticationService, NotificationService)
- **Infrastructure Services**: низкоуровневые (DatabaseService, FileService)

**Преимущества**

- **Переиспользование**: сервисы можно использовать в разных контекстах
- **Масштабируемость**: сервисы масштабируются независимо
- **Гибкость**: можно заменять реализации сервисов
- **Интеграция**: легче интегрировать разные системы через стандартные интерфейсы

**Недостатки**

- **Сложность**: нужна инфраструктура (ESB, мониторинг, управление версиями)
- **Производительность**: overhead на сетевые вызовы
- **Управление**: сложнее управлять распределенной системой
- **Согласованность**: сложнее обеспечить транзакционность

**Когда подходит**

- Крупные организации с множеством систем, которые нужно интегрировать
- Нужна стандартизация взаимодействия между системами
- Разные команды разрабатывают разные части системы
- Нужно переиспользовать функциональность

**Когда не подходит**

- Маленькие проекты, где overhead не оправдан
- Когда нужна максимальная производительность (меньше сетевых вызовов)
- Команда не готова поддерживать распределенную систему

**SOA vs Микросервисы**

SOA — более общий термин. Микросервисы — это конкретная реализация SOA с акцентом на:
- Маленькие, независимые сервисы
- Децентрализованное управление
- Отказ от централизованного ESB в пользу прямого взаимодействия
- DevOps-культура (каждая команда владеет своим сервисом)

## 5) Микросервисная архитектура (Microservices Architecture)

**Что это**

Архитектурный стиль, где система состоит из **небольших, независимых сервисов**, каждый из которых:
- Развертывается независимо
- Владеет своими данными
- Коммуницирует через легковесные механизмы (обычно HTTP/REST, gRPC, сообщения)
- Разрабатывается и поддерживается отдельной командой

**Ключевые характеристики**

- **Независимое развертывание**: каждый сервис можно деплоить отдельно
- **Технологическое разнообразие**: разные сервисы могут использовать разные стеки
- **Децентрализованное управление данными**: каждый сервис владеет своей БД
- **Отказоустойчивость**: отказ одного сервиса не должен ломать всю систему
- **Эволюционный дизайн**: система может расти и меняться постепенно

**Преимущества**

- **Масштабируемость**: масштабируем только нужные сервисы
- **Независимость команд**: команды могут работать параллельно
- **Технологическая гибкость**: можно выбирать подходящий стек для каждого сервиса
- **Отказоустойчивость**: изоляция сбоев
- **Быстрое развертывание**: маленькие сервисы деплоятся быстрее

**Недостатки**

- **Сложность**: распределенная система сложнее монолита
- **Сетевое взаимодействие**: latency, надежность сети
- **Управление данными**: сложнее транзакции, согласованность данных
- **Операционная сложность**: мониторинг, логирование, отладка распределенной системы
- **Тестирование**: сложнее интеграционное тестирование

**Когда подходит**

- Большие команды (10+ разработчиков)
- Разные части системы имеют разные требования к масштабированию
- Нужна технологическая гибкость
- Команда готова инвестировать в DevOps и операционную зрелость

**Когда не подходит (лучше монолит)**

- Маленькая команда (1-5 разработчиков)
- Неясные требования, нужна скорость итераций
- Простой домен без сложной бизнес-логики
- Нет опыта работы с распределенными системами

**Типичные проблемы и решения**

- **Управление данными**: Event Sourcing, CQRS, Saga для распределенных транзакций
- **Обнаружение сервисов**: Service Discovery (Consul, Eureka, Kubernetes)
- **Конфигурация**: Configuration Server, переменные окружения
- **Мониторинг**: распределенная трассировка (Jaeger, Zipkin), централизованное логирование
- **Безопасность**: API Gateway, OAuth2, mTLS

**Паттерны микросервисов**

- **API Gateway**: единая точка входа для клиентов
- **Service Mesh**: инфраструктурный слой для коммуникации (Istio, Linkerd)
- **Database per Service**: каждый сервис имеет свою БД
- **Saga**: управление распределенными транзакциями
- **Circuit Breaker**: защита от каскадных сбоев
- **Bulkhead**: изоляция ресурсов

**Размер сервиса**

Нет строгого правила. Критерии:
- Команда может владеть сервисом (2-pizza team)
- Сервис можно переписать за несколько недель
- Сервис решает одну бизнес-задачу (bounded context)

## Быстрое сравнение архитектурных стилей

| Критерий | Чистая/Гексагональная | Pipes and Filters | Event-Driven | SOA | Микросервисы |
|---|---|---|---|---|---|
| Фокус | Изоляция домена | Обработка данных | События | Сервисы | Независимые сервисы |
| Связанность | Низкая (слои) | Низкая (фильтры) | Очень низкая (события) | Средняя | Очень низкая |
| Сложность | Высокая | Средняя | Высокая | Высокая | Очень высокая |
| Масштабируемость | Средняя | Высокая (параллелизм) | Очень высокая | Высокая | Очень высокая |
| Тестируемость | Очень высокая | Высокая | Средняя | Средняя | Средняя |
| Когда использовать | Долгоживущие проекты | Обработка данных | Асинхронные системы | Интеграция систем | Большие команды |

## Мини-ответы "как на экзамене"

- **Чем гексагональная архитектура отличается от чистой**: гексагональная фокусируется на портах и адаптерах, чистая — на слоях с правилом зависимостей. По сути, это родственные подходы с разными акцентами.

- **Когда использовать pipes and filters**: для обработки данных в пакетном режиме, трансформаций (ETL), компиляторов. Не подходит для интерактивных систем.

- **Что такое событийно-ориентированная архитектура**: архитектура, где компоненты взаимодействуют через события. Издатель публикует событие, подписчики реагируют. Обеспечивает слабую связанность и масштабируемость.

- **Чем микросервисы отличаются от SOA**: микросервисы — это реализация SOA с акцентом на маленькие независимые сервисы, децентрализованное управление, отказ от централизованного ESB. SOA — более общий термин.

- **Когда не стоит использовать микросервисы**: маленькая команда, неясные требования, простой домен, нет опыта с распределенными системами. В таких случаях монолит часто лучше.
