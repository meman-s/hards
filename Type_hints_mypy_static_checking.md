# Type hints, mypy и статическая проверка типов в Python

## 1. Зачем нужны типы в Python

Python — язык с **динамической типизацией**: тип переменной определяется в runtime. Это даёт гибкость, но и риски: опечатки в именах, передача не того типа в функцию, ошибки обнаруживаются только при запуске.

**Статическая проверка типов** — анализ кода без запуска, на этапе разработки. Цели:
- раньше находить ошибки (до тестов и продакшена);
- улучшать читаемость и документацию кода (типы как контракт);
- лучше поддерживать рефакторинг и автодополнение в IDE.

Типы в Python **не меняют поведение** интерпретатора: это аннотации для инструментов и людей.

---

## 2. Type hints (аннотации типов)

### 2.1 Синтаксис

Аннотации задаются через двоеточие для переменных/параметров и `->` для возвращаемого значения функции.

```python
def greet(name: str) -> str:
    return f"Hello, {name}"

x: int = 42
items: list[str] = []
```

Аннотации **не обязательны** и **не проверяются** самим интерпретатором при выполнении (за исключением редкого использования `annotations` в коде).

### 2.2 Встроенные типы

- **Простые:** `int`, `float`, `str`, `bool`, `bytes`, `None`
- **Коллекции:** `list[Elem]`, `dict[Key, Value]`, `set[Elem]`, `tuple[Elem, ...]` или `tuple[E1, E2]`
- **Специальные:** `None` (часто в связке с `Optional`), `Any` (любой тип, отключает проверку)

В Python 3.9+ встроенные коллекции можно писать как `list[str]`; в 3.8 и раньше — `List[str]` из `typing`.

### 2.3 typing — основные конструкции

- **`Optional[T]`** — то же, что `T | None` (Python 3.10+): значение типа `T` или `None`.
- **`Union[A, B]`** — то же, что `A | B`: значение одного из типов.
- **`Any`** — любой тип; статический анализатор почти не проверяет.
- **`Callable[[Arg1, Arg2], Return]`** — тип функции (аргументы и возврат).
- **`TypeVar`** — переменная типа для обобщённого (generic) кода.
- **`Generic[T]`** — базовый класс для generic-классов.
- **`Literal["a", "b"]`** — только указанные литеральные значения.
- **`Final`** — константа (не должна переназначаться).
- **`TypedDict`** — словарь с фиксированными ключами и типами значений.
- **`Protocol`** — структурная типизация (как интерфейсы).

### 2.4 Примеры

```python
from typing import Optional, Callable, Union

def find(lst: list[str], x: str) -> Optional[int]:
    for i, v in enumerate(lst):
        if v == x:
            return i
    return None

def apply(f: Callable[[int], str], n: int) -> str:
    return f(n)

def parse_id(value: Union[str, int]) -> int:
    return int(value)
```

### 2.5 TypeVar и Generic[T] — подробнее

#### Зачем нужны

Без переменных типа обобщённый код пришлось бы описывать через `list[Any]` или дублировать функции для каждого типа. Тогда теряется информация: «функция вернула элемент того же типа, что и список» — анализатор этого не знает. **TypeVar** связывает типы между собой: «вход и выход — один и тот же тип T».

#### TypeVar — переменная типа

**TypeVar** объявляет «параметр типа» — плейсхолдер, который при вызове функции или использовании класса подставляется конкретным типом.

```python
from typing import TypeVar

T = TypeVar("T")

def first(lst: list[T]) -> T:
    return lst[0]
```

- `T` здесь — не конкретный тип, а «что угодно, но одно и то же».
- `first([1, 2, 3])` → анализатор выводит: аргумент `list[int]`, результат `int`.
- `first(["a", "b"])` → аргумент `list[str]`, результат `str`.
- Если бы возвращали `list[T]`, то тип результата был бы `list[T]` с тем же `T`.

Имя в кавычках (`TypeVar("T")`) должно совпадать с именем переменной (`T`) — это требование для корректной работы.

#### Ограничения TypeVar (bound, covariant)

- **bound=SomeType** — «T может быть только подтипом SomeType». Например, `TypeVar("T", bound=float)` — подойдут `float`, `int` (если считаем подтипом), но не `str`.
- **covariant / contravariant** — для продвинутой типизации при наследовании generic-классов (редко нужно на экзамене).

#### Generic[T] — обобщённые классы

Для **классов** «параметры типа» задают через наследование от **Generic[T]** (и при необходимости от других базовых классов). Тогда экземпляр класса можно типизировать: `Stack[int]`, `Stack[str]`.

```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []

    def push(self, x: T) -> None:
        self._items.append(x)

    def pop(self) -> T:
        return self._items.pop()
```

- `Stack[int]` — стек целых: `push` принимает `int`, `pop` возвращает `int`.
- `Stack[str]` — то же для строк. Анализатор проверяет, что в один и тот же стек не смешивают типы по-разному.

Без `Generic[T]` нельзя было бы выразить «этот стек хранит именно int’ы», только «какой-то тип».

#### Несколько параметров типа

Используют несколько TypeVar, когда типы независимы или связаны по-разному (например, ключ и значение словаря):

```python
from typing import TypeVar, Generic

K = TypeVar("K")
V = TypeVar("V")

class Pair(Generic[K, V]):
    def __init__(self, first: K, second: V) -> None:
        self.first = first
        self.second = second
```

#### Сводка

| Концепция | Роль |
|-----------|------|
| **TypeVar("T")** | Объявление переменной типа T; связывает типы в сигнатуре (один и тот же T на входах и выходах). |
| **Generic[T]** | Базовый класс, чтобы класс мог быть параметризован типом: `MyClass[T]`, `MyClass[int]`. |
| **bound** | Ограничение: T — только подтипы указанного типа. |

В функциях обычно достаточно **TypeVar**; в классах нужен **Generic[T]** (или несколько параметров: **Generic[K, V]**), чтобы тип элемента/поля класса был известен анализатору.

---

## 3. mypy

**mypy** — статический анализатор типов для Python. Читает аннотации и сообщает о несоответствиях типов, не запуская код.

### 3.1 Установка и запуск

```bash
pip install mypy
mypy script.py
mypy src/
```

### 3.2 Что проверяет mypy

- Совпадение типов аргументов и возвращаемых значений с аннотациями.
- Существование атрибутов и методов у объектов.
- Несоответствие типов при присваивании и в коллекциях.
- Частично — корректность использования `Optional`/`None`.

### 3.3 Режимы строгости

- **По умолчанию:** часть проверок отключена (например, не все функции обязаны иметь аннотации).
- **`--strict`** — максимально строгий режим (обязательные аннотации, запрет необработанного `Any` и т.д.).
- В конфиге можно включать отдельные проверки: `disallow_untyped_defs`, `check_untyped_defs`, `warn_return_any` и др.

### 3.4 Конфигурация

Файл **`mypy.ini`** или **`pyproject.toml`** (секция `[tool.mypy]`):

```ini
[mypy]
python_version = 3.11
strict = true
warn_return_any = true
warn_unused_ignores = true
```

Можно задавать разные опции для модулей:

```ini
[mypy-tests.*]
disallow_untyped_defs = false
```

### 3.5 Игнорирование

- Строка: `# type: ignore` или `# type: ignore[code]`.
- Файл: в конфиге `[[tool.mypy.overrides]]` с `ignore` для путей.

Игнор стоит использовать точечно, когда тип корректно выразить сложно или это сторонняя библиотека без типов.

---

## 4. Статическая проверка типов (общая теория)

### 4.1 Статическая vs динамическая типизация

- **Динамическая:** типы проверяются во время выполнения (Python по умолчанию).
- **Статическая:** типы проверяются до выполнения (компилятор/анализатор). В Python это делают mypy, Pyright, Pyre и др.

Python остаётся динамическим; статическая проверка — дополнительный слой.

### 4.2 Номинальная и структурная типизация

- **Номинальная:** совместимость по имени типа (как в Java, C++). В Python наследование даёт номинальную совместимость.
- **Структурная:** совместимость по наличию полей/методов (`Protocol` в Python — «утиная типизация» для статического анализатора).

### 4.3 Duck typing и типы

«Если оно крякает как утка — это утка.» В runtime Python не смотрит на аннотации; типы нужны для статического анализа и документации, не для изменения поведения.

### 4.4 Другие инструменты

- **Pyright** (Pylance в VS Code) — быстрый, часто используется в редакторах.
- **Pyre** (Meta) — строгая проверка.
- **pytype** (Google) — допускает частично нетипизированный код.

Они по-разному обрабатывают одни и те же аннотации; стиль аннотаций обычно совместим (PEP 484, typing).

---

## 5. Важные концепции для экзамена

| Концепция | Кратко |
|-----------|--------|
| Type hint | Аннотация типа (для переменной, аргумента, возврата), не выполняется интерпретатором |
| Optional[T] | T или None |
| Union[A, B] / A \| B | Значение типа A или B |
| Any | Любой тип, проверка по сути отключена |
| mypy | Статический анализатор типов для Python по PEP 484 |
| Статическая проверка | Анализ типов без запуска программы |
| Dynamic typing | Типы в Python проверяются в runtime; аннотации на это не влияют |
| Generic (TypeVar, Generic) | Обобщённые типы, например list[T], чтобы не терять точность типа |
| Protocol | Структурный подтип: «всё, у чего есть такие методы» |
| TypedDict | Словарь с заданными ключами и типами значений |
| Callable | Тип функции/метода по сигнатуре |
| strict mode (mypy) | Строгий режим: больше обязательных аннотаций и проверок |

---

## 6. Краткие упражнения (для самопроверки теории)

1. Чем `Optional[str]` отличается от `str` с точки зрения типов?
2. Что делает `# type: ignore` в коде для mypy?
3. Зачем нужен `TypeVar` в generic-функциях?
4. В чём разница между номинальной и структурной типизацией?
5. Может ли программа с ошибками типов по мнению mypy успешно выполняться в Python?

**Ответы (коротко):**  
1) `Optional[str]` = `str | None` — допускается None.  
2) Отключает проверку типов для данной строки (или конкретной ошибки).  
3) Чтобы сохранить связь между типами (например, «вход и выход одного типа») и не терять точность.  
4) Номинальная — по имени типа/наследованию; структурная — по наличию полей/методов (Protocol).  
5) Да; интерпретатор не проверяет аннотации, только mypy/другие анализаторы.

---

## 7. Полезные ссылки

- **PEP 484** — Type Hints.
- **PEP 585** — Type Hinting Generics In Standard Collections (list[str] и т.д.).
- **PEP 604** — Union с `X | Y`.
- Документация [mypy](https://mypy.readthedocs.io/).
- Модуль [typing](https://docs.python.org/3/library/typing.html) в стандартной библиотеке.
