# Архитектурные стили и подходы — подробный конспект

Этот конспект сделан по пункту из файла `Список тяжелых навыков - Степан.xlsx` → **Проектирование** → **Архитектурные стили**:

- Луковая архитектура / Чистая архитектура / Гексагональная архитектура / Архитектура портов и адаптеров
- Конвейерная архитектура / Архитектура каналов и фильтров (pipes and filters)
- Событийно-ориентированная архитектура
- Архитектура на основе сервисов
- Микросервисная архитектура

Цель: понимать **когда какой стиль выбирать**, **какие проблемы решает**, **какие компромиссы**, **как применять на практике**.

## Общая рамка: что такое архитектурный стиль

Архитектурный стиль — это **набор принципов организации системы**, которые определяют:
- Как компоненты взаимодействуют
- Как данные передаются
- Какие ограничения и правила действуют
- Какие проблемы решаются

Важно: стили можно комбинировать. Например, микросервисы могут использовать событийную архитектуру внутри.

## 1) Чистая архитектура и родственные подходы

### 1.1 Общая идея

Группа архитектурных стилей, которые разделяют систему на **слои с четкими зависимостями**: внешние слои зависят от внутренних, но не наоборот. Бизнес-логика изолирована от деталей реализации (БД, UI, фреймворки).

### 1.2 Гексагональная архитектура (Hexagonal Architecture / Ports and Adapters)

**Что это**

Архитектура, где приложение представлено как **шестиугольник** (гексагон), внутри которого — бизнес-логика, а снаружи — адаптеры для взаимодействия с внешним миром.

**Ключевые понятия**

- **Порты (Ports)**: интерфейсы, которые определяют, как приложение взаимодействует с внешним миром
  - Входящие порты (primary/driving): что приложение **предоставляет** (например, REST API, CLI)
  - Исходящие порты (secondary/driven): что приложение **использует** (например, БД, внешние сервисы)
- **Адаптеры (Adapters)**: конкретные реализации портов
  - Входящие адаптеры: контроллеры, обработчики HTTP, CLI-парсеры
  - Исходящие адаптеры: репозитории для БД, клиенты внешних API, файловые системы

**Структура зависимостей**

```
Внешний мир → Адаптеры → Порты → Доменная логика
```

Доменная логика **не знает** про HTTP, SQL, файлы. Она знает только про интерфейсы (порты).

**Примеры**

- Входящий порт: `interface OrderService { createOrder(order: Order): Promise<OrderId> }`
- Входящий адаптер: REST контроллер, который вызывает `OrderService`
- Исходящий порт: `interface OrderRepository { save(order: Order): Promise<void> }`
- Исходящий адаптер: PostgreSQL-реализация `OrderRepository`

**Короткий пример на Python (порты и адаптеры)**

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class Order:
    id: str
    total: float

class OrderRepositoryPort(ABC):
    @abstractmethod
    def save(self, order: Order) -> None: ...

class InMemoryOrderRepository(OrderRepositoryPort):
    def __init__(self):
        self._orders: list[Order] = []

    def save(self, order: Order) -> None:
        self._orders.append(order)

class CreateOrderUseCase:
    def __init__(self, repository: OrderRepositoryPort):
        self._repo = repository

    def execute(self, order_id: str, total: float) -> Order:
        order = Order(id=order_id, total=total)
        self._repo.save(order)
        return order

class CliOrderDriver:
    def __init__(self, use_case: CreateOrderUseCase):
        self._use_case = use_case

    def run(self, order_id: str, total: float) -> Order:
        return self._use_case.execute(order_id, total)

outgoing_adapter = InMemoryOrderRepository()
use_case = CreateOrderUseCase(outgoing_adapter)
incoming_adapter = CliOrderDriver(use_case)
order = incoming_adapter.run("ord-1", 99.99)
```
- **Входящий порт** — контракт «как приложение принимает команды». В примере это роль use case: у него метод `execute(order_id, total)`. Можно оформить как отдельный интерфейс (ABC) с методом `execute`, который реализует `CreateOrderUseCase`.
- **Исходящий порт** — `OrderRepositoryPort`: интерфейс (ABC) с методом `save`. Ядро зависит от него, а не от конкретной БД.
- **Входящий адаптер** — `CliOrderDriver`: переводит вызов из внешнего мира (CLI) в вызов use case.
- **Исходящий адаптер** — `InMemoryOrderRepository`: реализует порт `OrderRepositoryPort`, подменяема на PostgreSQL и т.д.

**Когда подходит**

- Нужна независимость от фреймворков и библиотек
- Планируются разные способы взаимодействия (REST, GraphQL, CLI, gRPC)
- Нужно легко тестировать бизнес-логику без БД/сети
- Команда хочет четко разделить ответственность

**Когда не подходит**

- Очень простые CRUD-приложения без сложной логики
- Прототипы и MVP, где скорость важнее структуры
- Команда не готова поддерживать абстракции

### 1.3 Чистая архитектура (Clean Architecture)

**Что это**

Подход Роберта Мартина, который расширяет идеи гексагональной архитектуры, добавляя **четкие слои с правилом зависимостей**.

**Слои (от внешнего к внутреннему)**

1. **Frameworks & Drivers**: UI, веб-фреймворки, БД, внешние библиотеки
2. **Interface Adapters**: контроллеры, презентеры, шлюзы (репозитории)
3. **Use Cases / Application**: бизнес-сценарии, оркестрация
4. **Entities / Domain**: бизнес-сущности и правила домена

**Правило зависимостей**

Зависимости направлены **внутрь**: внешние слои зависят от внутренних, внутренние не зависят от внешних.

**Пример структуры**

```
/api (Frameworks)
  /controllers (Interface Adapters)
    OrderController → вызывает
/application (Use Cases)
  /use-cases
    CreateOrderUseCase → использует
/domain (Entities)
  /entities
    Order, OrderItem
  /repositories (интерфейсы)
    IOrderRepository
/infrastructure (Frameworks)
  /repositories (реализации)
    PostgresOrderRepository implements IOrderRepository
```

**Подробный пример (слои и зависимости)**

Структура каталогов и назначение файлов:

```
project/
  api/
    main.py
    controllers/
      order_controller.py    # Interface Adapters: принимает HTTP, вызывает use case
  application/
    use_cases/
      create_order_use_case.py
  domain/
    entities/
      order.py               # Order, OrderItem — сущности без зависимостей
    repositories/
      order_repository.py    # IOrderRepository — только интерфейс (ABC)
  infrastructure/
    repositories/
      postgres_order_repository.py   # Реализация IOrderRepository для PostgreSQL
```

Поток вызова и зависимости:

- `OrderController` (api): получает запрос, парсит тело, вызывает `CreateOrderUseCase.execute(...)`, возвращает HTTP-ответ. Импортирует только из `application` и `domain`.
- `CreateOrderUseCase` (application): принимает `IOrderRepository` в конструкторе, в `execute()` создаёт `Order`, вызывает `repository.save(order)`. Импортирует только из `domain` (сущности и интерфейс репозитория).
- `Order`, `OrderItem` (domain): чистые структуры данных и доменные правила. Ничего не импортируют из остальных слоёв.
- `IOrderRepository` (domain): абстрактный интерфейс с методом `save(order: Order) -> None`. Определён в домене, реализуется снаружи.
- `PostgresOrderRepository` (infrastructure): реализует `IOrderRepository`, внутри — SQL/драйвер БД. Импортирует из `domain` (интерфейс и сущности).

Сборка (композиция корня) делается в одном месте (например `api/main.py` или `composition_root.py`): создаётся `PostgresOrderRepository`, ему передаётся конфиг БД; создаётся `CreateOrderUseCase(repository)`; создаётся `OrderController(use_case)`; контроллер регистрируется во фреймворке. Домен и use case не знают про HTTP и PostgreSQL.

**Когда подходит**

- Большие долгоживущие проекты
- Нужна максимальная гибкость: замена БД, UI, фреймворков
- Команда готова инвестировать в структуру

**Когда не подходит**

- Маленькие проекты, где overhead структуры не оправдан
- Команда не понимает принципы и будет нарушать правила

### 1.4 Луковая архитектура (Onion Architecture)

**Что это**

Вариант чистой архитектуры, где слои представлены как **концентрические круги** (как луковица).

**Слои (от центра к краю)**

1. **Domain Model** (центр): сущности и интерфейсы репозиториев
2. **Domain Services**: бизнес-логика, которая не принадлежит одной сущности
3. **Application Services**: use cases, оркестрация
4. **Infrastructure / UI**: реализации репозиториев, контроллеры, внешние сервисы

**Когда подходит**

- DDD (Domain-Driven Design) проекты
- Когда доменная модель — главная ценность
- Нужна четкая изоляция домена

**Чем чистая архитектура отличается от луковой**

Общее: в обеих зависимость направлена **внутрь** (к домену); инфраструктура и UI зависят от внутренних слоёв, домен не зависит от БД и фреймворков.

| | Чистая архитектура | Луковая архитектура |
|---|---------------------|----------------------|
| **Метафора** | Слои (прямоугольники или круги) | Концентрические круги (луковица) |
| **Слои** | Entities → Use Cases → Interface Adapters → Frameworks & Drivers | Domain Model → Domain Services → Application Services → Infrastructure/UI |
| **Центр** | Entities (сущности) | Domain Model (сущности + интерфейсы репозиториев) |
| **Слой между доменом и use cases** | Не выделяется явно; оркестрация в Use Cases | **Domain Services** — явный слой: логика, не привязанная к одной сущности |
| **Акцент** | Чёткое правило зависимостей и границы слоёв | Домен в центре; всё «нарастает» вокруг него |

На практике: чистая архитектура сильнее акцентирует **use cases** и **interface adapters** (контроллеры, презентеры); луковая — **домен и доменные сервисы**. Идеи совместимы, многие команды смешивают названия слоёв. Выбор чаще про терминологию и визуализацию, чем про противоречащие правила.

**Конкретные примеры (один сценарий: создание заказа с проверкой лимита и бонусами)**

Сценарий: пользователь создаёт заказ; нужно проверить кредитный лимит клиента, сохранить заказ, начислить бонусы. Логика «можно ли выдать заказ этому клиенту» затрагивает и клиента, и заказ — не одна сущность.

**Чистая архитектура**

- **Entities**: `Order` (id, customer_id, total, items), `Customer` (id, credit_limit, current_debt). Минимум логики: например, `order.total` как свойство.
- **Use Case** `CreateOrderUseCase`: оркестрация целиком здесь. Внутри: достать `Customer` через `ICustomerRepository`, проверить `current_debt + order.total <= credit_limit`, сохранить `Order` через `IOrderRepository`, вызвать `IBonusGateway.accrue(customer_id, points)`. Вся проверка лимита и решение «сколько бонусов» могут быть прямо в use case или в мелких хелперах.
- **Interface Adapters**: `OrderController` (парсит HTTP → вызывает `CreateOrderUseCase.execute()`), `IOrderRepository` / `ICustomerRepository` (интерфейсы), презентер при необходимости.
- **Frameworks**: `PostgresOrderRepository`, `HttpClientBonusGateway`, FastAPI/Flask.

Итог: «можно ли оформить заказ» и «сколько бонусов начислить» живут в **use case** (или в простых функциях рядом с ним). Отдельного слоя «доменных сервисов» нет.

**Луковая архитектура**

- **Domain Model**: те же `Order`, `Customer` плюс интерфейсы `IOrderRepository`, `ICustomerRepository` в центре.
- **Domain Services**: явный слой с правилами, которые не принадлежат одной сущности. Например, `CreditLimitPolicy.can_place_order(customer: Customer, order: Order) -> bool` — проверка лимита; `BonusCalculator.points_for(order: Order) -> int` — расчёт бонусов. Это доменная логика, но не метод одного объекта.
- **Application Services**: `CreateOrderApplicationService` только оркестрирует: получить клиента и заказ, вызвать `CreditLimitPolicy.can_place_order(...)`, если ок — сохранить заказ через репозиторий, вызвать `BonusCalculator.points_for(order)` и отдать во внешний сервис начислений. Без формул и правил — только вызовы доменных сервисов и репозиториев.
- **Infrastructure / UI**: те же контроллеры, репозитории PostgreSQL, клиент бонусного API.

Итог: правила «можно ли заказ» и «сколько бонусов» вынесены в **Domain Services**; application-слой только координирует вызовы. Домен богаче, use case тоньше.

**Сводка на примере**

| Вопрос | Чистая | Луковая |
|--------|--------|---------|
| Где проверка кредитного лимита? | В use case (или хелпер рядом) | В Domain Service (`CreditLimitPolicy`) |
| Где расчёт бонусов? | В use case | В Domain Service (`BonusCalculator`) |
| Где «сохранить заказ»? | Use case вызывает `IOrderRepository` | Application Service вызывает `IOrderRepository` |
| Кто знает про HTTP/БД? | Только контроллеры и репозитории снаружи | То же |

Так проще увидеть разницу: в чистой архитектуре оркестрация и часть правил в use case; в луковой правила выносятся в доменные сервисы, а слой приложения остаётся тонким координатором.

### 1.5 Сравнение и выбор

| Критерий | Гексагональная | Чистая | Луковая |
|---|---|---|---|
| Фокус | Порты и адаптеры | Слои и зависимости | Домен в центре |
| Сложность | Средняя | Высокая | Высокая |
| Подходит для | Средние проекты | Большие проекты | DDD проекты |
| Тестируемость | Высокая | Очень высокая | Очень высокая |

**Практический совет**

Для большинства проектов достаточно **гексагональной архитектуры** с разделением на:
- Домен (entities, value objects, domain services)
- Приложение (use cases, application services)
- Инфраструктура (репозитории, контроллеры, внешние клиенты)

## 2) Конвейерная архитектура (Pipes and Filters)

**Что это**

Архитектура, где данные обрабатываются через **цепочку независимых фильтров**, соединенных **каналами** (pipes).

**Ключевые компоненты**

- **Фильтры (Filters)**: независимые компоненты, которые обрабатывают данные
  - Могут быть stateless или stateful
  - Принимают входные данные, обрабатывают, возвращают результат
- **Каналы (Pipes)**: передают данные между фильтрами
  - Обычно однонаправленные
  - Могут буферизовать данные

**Типы фильтров**

- **Producer**: источник данных (читает файл, принимает запрос)
- **Transformer**: преобразует данные (парсинг, валидация, форматирование)
- **Tester**: проверяет условие, пропускает или блокирует
- **Consumer**: конечный получатель (сохраняет, отправляет)

**Примеры**

- Компиляторы: лексический анализ → парсинг → оптимизация → генерация кода
- ETL-процессы: извлечение → трансформация → загрузка
- Обработка изображений: загрузка → ресайз → фильтр → сохранение
- Unix pipelines: `cat file.txt | grep "error" | sort | uniq`

**Преимущества**

- **Модульность**: каждый фильтр независим, легко тестировать
- **Параллелизм**: фильтры могут работать параллельно
- **Гибкость**: легко добавлять/удалять/переставлять фильтры
- **Повторное использование**: фильтры можно комбинировать по-разному

**Недостатки**

- Не подходит для интерактивных систем (нужна обратная связь)
- Сложно обрабатывать ошибки в середине цепочки
- Может быть overhead на передачу данных между фильтрами

**Когда подходит**

- Обработка данных в пакетном режиме
- Трансформации данных (ETL, конвейеры данных)
- Компиляторы и интерпретаторы
- Обработка потоков событий (с модификациями)

**Когда не подходит**

- Интерактивные приложения с UI
- Системы, где нужна сложная координация между компонентами
- Когда производительность критична и overhead передачи данных недопустим

**Практический пример**

```python
def read_file(path: str) -> Iterator[str]:
    with open(path) as f:
        yield from f

def filter_errors(lines: Iterator[str]) -> Iterator[str]:
    return (line for line in lines if "error" in line.lower())

def uppercase(lines: Iterator[str]) -> Iterator[str]:
    return (line.upper() for line in lines)

def write_file(lines: Iterator[str], path: str):
    with open(path, 'w') as f:
        f.writelines(lines)

pipeline = read_file("log.txt") | filter_errors | uppercase | write_file("errors.txt")
```

## 3) Событийно-ориентированная архитектура (Event-Driven Architecture, EDA)

**Что это**

Архитектура, где компоненты взаимодействуют через **события**: один компонент публикует событие, другие подписываются и реагируют.

**Ключевые понятия**

- **Событие (Event)**: факт, что что-то произошло (immutable, прошлое время: "OrderCreated", "PaymentProcessed")
- **Издатель (Publisher/Producer)**: компонент, который публикует события
- **Подписчик (Subscriber/Consumer)**: компонент, который обрабатывает события
- **Брокер событий (Event Broker)**: промежуточный слой (очередь, шина событий), который доставляет события

**Модели взаимодействия**

1. **Pub/Sub (Publish-Subscribe)**: издатель не знает, кто подписан. Брокер доставляет событие всем подписчикам.
2. **Event Streaming**: события хранятся в логе, подписчики читают с нужной позиции (Kafka, EventStore).
3. **Event Sourcing**: состояние системы восстанавливается из потока событий.

**Преимущества**

- **Слабая связанность**: компоненты не знают друг о друге напрямую
- **Масштабируемость**: подписчики могут масштабироваться независимо
- **Гибкость**: легко добавлять новых подписчиков без изменения издателей
- **Асинхронность**: обработка может быть отложенной
- **Аудит**: события — это история изменений

**Недостатки**

- **Сложность отладки**: поток событий может быть неочевидным
- **Согласованность**: сложнее обеспечить транзакционность между компонентами
- **Порядок событий**: нужно учитывать порядок и дубликаты
- **Тестирование**: сложнее тестировать распределенные сценарии

**Когда подходит**

- Микросервисы, которым нужно слабое связывание
- Системы, где компоненты должны реагировать на изменения независимо
- Нужна история изменений (аудит, аналитика)
- Асинхронная обработка (уведомления, интеграции)

**Когда не подходит**

- Простые CRUD-приложения без сложных интеграций
- Когда нужна строгая транзакционность между операциями
- Команда не готова работать с асинхронностью и eventual consistency

**Практические паттерны**

- **Event Sourcing**: храним события, состояние вычисляем
- **CQRS**: разделение на команды (write) и запросы (read), синхронизация через события
- **Saga**: распределенные транзакции через цепочку событий

**Примеры событий**

- `OrderCreated(orderId, customerId, items)`
- `PaymentProcessed(orderId, amount, method)`
- `InventoryReserved(orderId, items)`
- `OrderShipped(orderId, trackingNumber)`

## 4) Архитектура на основе сервисов (Service-Oriented Architecture, SOA)

**Что это**

Архитектурный стиль, где функциональность организована как **набор сервисов**, которые взаимодействуют через **стандартизированные интерфейсы**. Появился в 2000-х для интеграции корпоративных систем (ERP, CRM, биллинг), часто поверх ESB (Enterprise Service Bus).

**Ключевые принципы**

- **Сервисы**: автономные, переиспользуемые компоненты с чётким контрактом (WSDL, OpenAPI)
- **Слабая связанность**: сервисы взаимодействуют через контракты, не знают детали реализации друг друга
- **Стандартизация**: общие протоколы (часто SOAP/WS-*, позже REST), форматы (XML, JSON), единые форматы сообщений
- **Композиция**: сложные процессы (оркестрация) собираются из вызовов сервисов

**Как устроена SOA**

Типичная топология — **звезда с центром в виде шины**:

```
                    ┌─────────────────┐
                    │   ESB / Шина    │
                    │ маршрутизация,  │
                    │ трансформация,  │
                    │ оркестрация     │
                    └────────┬────────┘
         ┌──────────────────┼──────────────────┐
         ▼                  ▼                  ▼
   ┌──────────┐      ┌──────────┐      ┌──────────┐
   │ Сервис A │      │ Сервис B │      │ Сервис C │
   │ (ERP)    │      │ (CRM)    │      │ (Billing)│
   └──────────┘      └──────────┘      └──────────┘
```

- Клиенты и приложения обращаются к **ESB**, а не напрямую к сервисам. ESB маршрутизирует запросы, преобразует форматы (XML одного формата → XML другого), может оркестрировать цепочки вызовов (BPEL и аналоги).
- **Service Registry** (UDDI, или каталог сервисов): где какой сервис, какая версия контракта. Потребители находят сервис по контракту.
- Сервисы могут быть **крупными**: целое приложение (например, биллинг) экспонирует один или несколько сервисов. Граница — часто по подсистеме/приложению, а не по маленькой бизнес-операции.

**Компоненты SOA**

- **Service Provider**: приложение, которое предоставляет сервис (контракт + реализация). Может быть монолитом.
- **Service Consumer**: приложение или процесс, которое вызывает сервис через контракт.
- **Service Registry**: каталог сервисов и контрактов (опционально).
- **ESB (Enterprise Service Bus)**: центральный слой. Принимает сообщения/вызовы, маршрутизирует к провайдерам, трансформирует форматы, логирует, иногда оркестрирует сценарии.

**Типы сервисов**

- **Business Services**: бизнес-функциональность (OrderManagementService, CustomerService, InvoiceService) — крупные, часто по границам приложений.
- **Application Services**: технические сервисы (AuthenticationService, NotificationService).
- **Infrastructure Services**: низкоуровневые (DocumentStorageService, ReportingService).

**Пример в стиле SOA (предприятие)**

Есть три старых системы: ERP (склад, заказы), CRM (клиенты, лиды), Billing (счета, оплаты). Их нужно связать без переписывания.

- **ERP** экспонирует сервисы: `CreateOrder`, `ReserveStock`, `GetOrderStatus`. Контракт SOAP/XML.
- **CRM** экспонирует: `GetCustomer`, `UpdateCustomer`, `CreateLead`. Контракт SOAP/XML.
- **Billing** экспонирует: `CreateInvoice`, `RegisterPayment`, `GetBalance`. Контракт SOAP/XML.

Новый процесс «оформить заказ из лида» реализуется **в ESB** (оркестрация): получить лид из CRM → создать клиента/заказ в ERP → создать счёт в Billing → обновить лид в CRM. Все вызовы идут через шину; форматы приводятся к единому виду в ESB. Сервисы остаются крупными (целые приложения), переиспользуются в других процессах.

**Преимущества**

- **Переиспользование**: один сервис (например, Billing) используется из разных процессов и приложений.
- **Стандартизация**: единые протоколы и контракты упрощают интеграцию между отделами и вендорами.
- **Централизованное управление**: маршрутизация, безопасность, логирование в одном месте (ESB).
- **Интеграция legacy**: старые системы оборачиваются в сервисы и подключаются к шине.

**Недостатки**

- **Единая точка отказа и узкое горло**: ESB становится критичным и может ограничивать пропускную способность.
- **Сложность**: настройка ESB, контрактов, трансформаций; тяжёлые стандарты (SOAP, WS-*).
- **Согласованность**: распределённые транзакции и консистентность данных сложнее.
- **Жёсткость**: изменение контракта затрагивает многих потребителей; централизованные релизы.

**Когда подходит**

- Крупные организации с множеством разнородных систем (ERP, CRM, биллинг, партнёры), которые нужно интегрировать.
- Нужна единая точка интеграции и стандартизация взаимодействия.
- Переиспользование функциональности в разных бизнес-процессах.
- Регуляторика или корпоративные стандарты требуют централизованного контроля обмена.

**Когда не подходит**

- Маленькие проекты или один продукт без множества legacy-систем.
- Нужна высокая скорость изменений и независимые релизы (ESB и общие контракты замедляют).
- Команда не готова поддерживать ESB и сложные контракты.

## 5) Микросервисная архитектура (Microservices Architecture)

**Что это**

Архитектурный стиль, где система состоит из **небольших, независимых сервисов**, каждый из которых:
- Развёртывается **независимо** (свой конвейер, свой репозиторий)
- **Владеет своими данными** (своя БД или схема; другие сервисы не обращаются к ней напрямую)
- Коммуницирует через **лёгкие** механизмы: HTTP/REST, gRPC, асинхронные очереди (RabbitMQ, Kafka)
- Разрабатывается и поддерживается **одной командой** (идея «one team — one service»)

**Как устроены микросервисы**

Топология — **сеть сервисов без центральной шины**: прямой вызов сервис–сервис или через шину сообщений. Единая точка входа для клиентов — API Gateway.

```
   Клиент (Web/Mobile)
          │
          ▼
   ┌──────────────┐
   │ API Gateway  │  (маршрутизация, аутентификация, агрегация)
   └──────┬───────┘
          │
   ┌──────┴──────┬──────────────┬──────────────┐
   ▼             ▼              ▼              ▼
┌───────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│ Order │   │ Catalog │   │ Payment │   │Shipping │
│Service│   │ Service │   │ Service │   │ Service │
│+ БД   │   │ + БД    │   │ + БД    │   │ + БД    │
└───┬───┘   └────┬────┘   └────┬────┘   └────┬────┘
    │            │             │             │
    └────────────┴──────┬──────┴─────────────┘
                       ▼
              ┌─────────────────┐
              │ Message Broker  │  (Kafka, RabbitMQ — события, асинхронность)
              └─────────────────┘
```

- **API Gateway**: клиент ходит только в шлюз; шлюз маршрутизирует на нужный сервис, может агрегировать ответы нескольких сервисов, занимается аутентификацией и лимитами.
- **Прямые вызовы**: синхронные запросы между сервисами (REST, gRPC). Например, Order при создании заказа вызывает Payment и Catalog.
- **Очереди/события**: асинхронное взаимодействие (Order опубликовал `OrderCreated`, Shipping и Notification подписаны). Слабая связанность, отказоустойчивость.
- **Database per Service**: у Order Service — своя БД (таблицы заказов), у Payment — своя (транзакции, балансы). Общей БД нет; обмен только через API или события.

**Ключевые характеристики**

- **Независимое развёртывание**: каждый сервис имеет свой репозиторий и конвейер; деплой одного не тянет за собой остальные.
- **Технологическое разнообразие**: Order на Java, Catalog на Go, аналитика на Python — допустимо, контракт по API/событиям.
- **Децентрализованное управление данными**: каждый сервис владеет своей моделью данных; дублирование данных между сервисами допускается (например, копия имени клиента в Order и в Shipping), согласованность — через события или саги.
- **Отказоустойчивость**: падение одного сервиса не должно ронять все (Circuit Breaker, fallback, асинхронность).
- **Эволюционный дизайн**: можно добавлять новые сервисы и менять границы по мере понимания домена.

**Пример: интернет-магазин на микросервисах**

- **Order Service**: создание заказа, статусы, корзина. Владеет данными заказов. При создании заказа публикует событие `OrderCreated` или синхронно вызывает Payment и Catalog (резерв).
- **Catalog Service**: каталог товаров, остатки, цены. Свой хранилище. Отдаёт данные по запросу; может подписаться на события заказов для обновления остатков.
- **Payment Service**: приём оплаты, статусы платежей. Свой БД. Вызывается из Order или реагирует на событие `OrderCreated`.
- **Shipping Service**: доставка, трекинг. Получает данные о заказе через событие или вызов Order API; хранит только то, что нужно для доставки.
- **Notification Service**: email/SMS. Подписан на события (`OrderCreated`, `OrderShipped`, `PaymentReceived`); не вызывает другие сервисы по бизнес-логике.

Один сценарий «оформить заказ»: клиент → API Gateway → Order Service; Order вызывает Catalog (резерв/проверка) и Payment (создать платёж); после успеха публикует `OrderCreated`; Shipping и Notification реагируют на события. Транзакции распределённые — через Saga (компенсирующие шаги при отказе).

**Преимущества**

- **Масштабируемость**: масштабируем только узкие места (например, Catalog при нагрузке на каталог).
- **Независимость команд**: команды владеют сервисами целиком, релизы не блокируют друг друга.
- **Технологическая гибкость**: разный стек под задачу.
- **Изоляция сбоев**: падение Payment не роняет чтение каталога при правильной обработке (Circuit Breaker, таймауты).
- **Быстрые релизы**: маленький сервис проще и быстрее деплоить.

**Недостатки**

- **Сложность**: распределённая система, отладка, трассировка, согласованность данных.
- **Сеть**: задержки, таймауты, повторные попытки, идемпотентность.
- **Данные**: нет единой ACID-транзакции между сервисами; саги, eventual consistency, дублирование.
- **Операционка**: мониторинг, логи, метрики, деплой множества сервисов (часто нужен Kubernetes, CI/CD).
- **Тестирование**: сложнее end-to-end и интеграционные сценарии.

**Типичные проблемы и решения**

- **Управление данными**: Saga (оркестрация или хореография), Event Sourcing, CQRS; явная eventual consistency.
- **Обнаружение сервисов**: Service Discovery (Consul, Eureka, в K8s — DNS и сервисы).
- **Конфигурация**: конфиг-сервер, переменные окружения, секреты (Vault).
- **Мониторинг**: распределённая трассировка (Jaeger, Zipkin), единый лог (ELK, Loki), метрики (Prometheus), алерты.
- **Безопасность**: API Gateway (аутентификация, лимиты), OAuth2/JWT, mTLS между сервисами (часто через Service Mesh).

**Паттерны микросервисов**

- **API Gateway**: единая точка входа, маршрутизация, агрегация, аутентификация.
- **Service Mesh** (Istio, Linkerd): трафик между сервисами, retry, circuit breaker, mTLS без изменения кода приложения.
- **Database per Service**: у каждого сервиса своя БД; обмен только через API/события.
- **Saga**: распределённая транзакция через локальные шаги и компенсации при сбое.
- **Circuit Breaker**: при повторных ошибках вызываемого сервиса не слать запросы, отдавать fallback или ошибку.
- **Bulkhead**: изоляция пулов ресурсов (потоки, соединения), чтобы сбой одного клиента не забирал все ресурсы.

**Размер сервиса**

Жёсткого правила нет. Ориентиры:
- **Одна команда** может полностью владеть сервисом (2-pizza team).
- Сервис можно **переписать за несколько недель** при необходимости.
- **Один bounded context** или одна зона ответственности (заказы, каталог, оплата, доставка).
- Не «один сервис на одну таблицу», а «один сервис на один бизнес-капабилити».

## SOA и микросервисы: отличия и сравнение

**Кратко**

SOA и микросервисы — оба «сервисные» стили, но SOA — **общий термин** с акцентом на стандартизацию, переиспользование и часто **центральную шину (ESB)**. Микросервисы — **конкретный вариант** с акцентом на **мелкие сервисы**, **децентрализацию**, **отказ от ESB** и **ownership командой**.

**Сравнительная таблица**

| Критерий | SOA | Микросервисы |
|----------|-----|--------------|
| **Размер сервиса** | Крупные: приложение/подсистема (ERP, Billing, CRM) | Небольшие: один bounded context, одна зона ответственности |
| **Централизация** | Часто ESB: маршрутизация, трансформация, оркестрация через шину | Нет ESB: прямой вызов сервис–сервис или через брокер сообщений; API Gateway только для клиентов |
| **Связь** | Часто синхронная через шину, стандарты (SOAP, WS-*) | REST, gRPC, плюс асинхронные очереди/события (Kafka, RabbitMQ) |
| **Данные** | Могут быть общие БД у разных приложений; сервисы часто оборачивают существующие системы | Database per Service; обмена данными только через API или события |
| **Оркестрация** | Часто в ESB (BPEL и аналоги) или централизованно | В одном из сервисов (оркестратор) или через события (хореография) |
| **Контракты** | Жёсткие, стандартизированные (WSDL, общие XSD); изменение затрагивает многих | Относительно гибкие; версионирование API, совместимость по обратной совместимости |
| **Цель** | Интеграция существующих систем, переиспользование, стандартизация | Независимое развёртывание, скорость изменений, ownership командой |
| **Типичный контекст** | Крупное предприятие, много legacy (ERP, CRM, партнёры) | Один продукт/платформа, большая команда, нужна скорость и гибкость |

**Один и тот же сценарий: «оформить заказ»**

- **В SOA**: клиент или процесс отправляет запрос в **ESB**. ESB по правилам оркестрации вызывает: CRM (получить/создать клиента) → ERP (создать заказ, резерв) → Billing (выставить счёт). Форматы между системами разные — ESB их преобразует. Все три системы — крупные, со своими БД; общая транзакция через координацию на шине или компенсации. Релиз изменений часто согласованный (контракты общие).

- **В микросервисах**: клиент идёт в **API Gateway** → **Order Service**. Order Service сам оркестрирует: вызов Catalog (резерв/проверка), вызов Payment (создать платёж); после успеха публикует событие `OrderCreated`. Shipping и Notification подписаны на события и действуют асинхронно. Каждый сервис со своей БД; согласованность через Saga и события. Order Service можно деплоить отдельно; контракт между Order и Payment версионируется (v1, v2), без единого центрального контракта на всю систему.

**Когда что выбирать**

- **SOA** уместна, когда главное — **интеграция разнородных систем** (свои и чужие, legacy), единые корпоративные стандарты и централизованный контроль обмена. Сервисы при этом могут оставаться крупными.
- **Микросервисы** уместны, когда главное — **один продукт/платформа**, большая команда, нужны **независимые релизы**, гибкость технологий и масштабирование по частям. Центральная шина нежелательна.

Микросервисы можно считать **частным случаем SOA** (всё равно «сервисы» и контракты), но с другими акцентами: мелкие сервисы, децентрализация, без ESB, DevOps и ownership.

## Быстрое сравнение архитектурных стилей

| Критерий | Чистая/Гексагональная | Pipes and Filters | Event-Driven | SOA | Микросервисы |
|---|---|---|---|---|---|
| Фокус | Изоляция домена | Обработка данных | События | Сервисы | Независимые сервисы |
| Связанность | Низкая (слои) | Низкая (фильтры) | Очень низкая (события) | Средняя | Очень низкая |
| Сложность | Высокая | Средняя | Высокая | Высокая | Очень высокая |
| Масштабируемость | Средняя | Высокая (параллелизм) | Очень высокая | Высокая | Очень высокая |
| Тестируемость | Очень высокая | Высокая | Средняя | Средняя | Средняя |
| Когда использовать | Долгоживущие проекты | Обработка данных | Асинхронные системы | Интеграция систем | Большие команды |

## Мини-ответы "как на экзамене"

- **Чем гексагональная архитектура отличается от чистой**: гексагональная фокусируется на портах и адаптерах, чистая — на слоях с правилом зависимостей. По сути, это родственные подходы с разными акцентами.

- **Когда использовать pipes and filters**: для обработки данных в пакетном режиме, трансформаций (ETL), компиляторов. Не подходит для интерактивных систем.

- **Что такое событийно-ориентированная архитектура**: архитектура, где компоненты взаимодействуют через события. Издатель публикует событие, подписчики реагируют. Обеспечивает слабую связанность и масштабируемость.

- **Чем микросервисы отличаются от SOA**: микросервисы — это реализация SOA с акцентом на маленькие независимые сервисы, децентрализованное управление, отказ от централизованного ESB. SOA — более общий термин.

- **Когда не стоит использовать микросервисы**: маленькая команда, неясные требования, простой домен, нет опыта с распределенными системами. В таких случаях монолит часто лучше.
