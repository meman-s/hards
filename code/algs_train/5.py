"""
Задание: Обратный связный список

Что такое односвязный список:
  Каждый узел хранит значение (val) и ссылку на следующий узел (next). Последний узел: next = None.
  Голова (head) — это первый узел; по нему мы получаем доступ ко всему списку.
  Пример: head → 1 → 2 → 3 → None  (три узла, значения 1, 2, 3).

Что значит «развернуть»:
  Направление ссылок меняется на противоположное. Было: 1→2→3→None. Стало: 3→2→1→None.
  Новая голова — бывший последний узел (3). Его и нужно вернуть.

Что будет дано на вход программе (два варианта):

  1) Ты запускаешь скрипт сам и вводишь данные с клавиатуры.
     Тогда на вход программе — одна строка, например:  1 2 3
     Ты читаешь её (input()), парсишь числа, по ним создаёшь узлы и связываешь в список.
     Получается head. Дальше вызываешь свою функцию разворота с этим head, результат — новая голова; по ней проходишь и выводишь значения (например 3 2 1).

  2) Это задача с автотестами (LeetCode и т.п.).
     Тогда input() нет. Тесты сами создают список и вызывают твою функцию, передавая head.
     Твоя функция принимает один аргумент — head (узел) — и возвращает новую голову.

В обоих случаях функция разворота получает на вход один объект: узел head (у него есть .val и .next). Не список, не строку — именно первый узел связного списка.
Выход функции: новая голова (тоже узел).

Пример того, как устроены узлы и что такое head:

  class Node:
      def __init__(self, val=0, next=None):
          self.val = val
          self.next = next

  n3 = Node(3, None)
  n2 = Node(2, n3)
  n1 = Node(1, n2)
  head = n1

  Сейчас: head — это n1, n1.next — n2, n2.next — n3, n3.next — None. Цепочка 1→2→3.
  Твоя функция получает head (т.е. n1). После разворота нужно вернуть n3: цепочка станет 3→2→1.
  На вход в программу приходит именно ссылка на первый узел (head), не список [1,2,3] и не input().

Ограничение: не создавать новый список и не копировать значения — только менять ссылки .next. Память O(1).

Как делать итеративно:
  Идёшь по списку и на каждом узле «переворачиваешь» стрелку: было curr.next = следующий, делаешь curr.next = предыдущий.
  Для этого храни три вещи: предыдущий узел (prev), текущий (curr), и заранее сохрани следующий (nxt = curr.next),
  иначе после смены curr.next ты потеряешь ссылку на остаток списка. После шага сдвигаешь prev, curr вперёд.
  Начало: prev = None, curr = head. Конец: curr станет None, новая голова — это последний не-None узел (prev в момент выхода).
"""

from dataclasses import dataclass


@dataclass
class Node:
    val: int = 0
    next: 'Node' | None


def reverse_list(head: Node) -> Node:
    prev, curr = None, head
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev
