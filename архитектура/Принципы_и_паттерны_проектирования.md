# Принципы и паттерны проектирования — подробный конспект

Этот конспект сделан по пункту из файла `Список тяжелых навыков - Степан.xlsx` → **Проектирование** → **Принципы и паттерны**:

- SOLID, DRY, KISS, YAGNI
- Паттерны проектирования GoF (Gang of Four)
- Архитектурные паттерны

Цель: понимать **когда применять принципы**, **какие паттерны решают какие проблемы**, **как не переусложнить**, **как выбирать паттерн**.

## Общая рамка: принципы vs паттерны

- **Принципы** (SOLID, DRY, KISS, YAGNI): общие правила и рекомендации, как писать хороший код
- **Паттерны проектирования** (GoF): типовые решения часто встречающихся проблем проектирования
- **Архитектурные паттерны**: решения на уровне архитектуры системы (MVC, Repository, CQRS)

Принципы помогают принимать решения. Паттерны — готовые решения для типовых проблем.

## 1) Принципы проектирования

### 1.1 SOLID

SOLID — это пять принципов объектно-ориентированного проектирования, которые помогают писать поддерживаемый и расширяемый код.

#### S — Single Responsibility Principle (Принцип единственной ответственности)

**Что это**

Класс должен иметь **только одну причину для изменения**. Или: класс должен отвечать за одну вещь.

**Проблема**

Класс, который делает слишком много:
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def save_to_database(self):
        # сохранение в БД
    
    def send_email(self):
        # отправка email
    
    def validate_email(self):
        # валидация email
    
    def generate_report(self):
        # генерация отчета
```

Этот класс меняется, если:
- Меняется структура пользователя
- Меняется способ сохранения в БД
- Меняется способ отправки email
- Меняется логика валидации
- Меняется формат отчета

**Решение**

Разделить на классы с одной ответственностью:
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user: User):
        # сохранение в БД

class EmailService:
    def send(self, user: User, message: str):
        # отправка email

class EmailValidator:
    def validate(self, email: str) -> bool:
        # валидация email

class UserReportGenerator:
    def generate(self, user: User) -> Report:
        # генерация отчета
```

**Как определить ответственность**

Спроси: "Почему этот класс может измениться?" Если ответов больше одного — нарушение SRP.

**Когда нарушать**

В простых случаях (прототипы, утилиты) можно объединять, но понимать компромисс.

#### O — Open/Closed Principle (Принцип открытости/закрытости)

**Что это**

Классы должны быть **открыты для расширения, но закрыты для модификации**. Можно добавлять новую функциональность, не меняя существующий код.

**Проблема**

Добавление новой функциональности требует изменения существующего кода:
```python
class AreaCalculator:
    def calculate(self, shape):
        if isinstance(shape, Rectangle):
            return shape.width * shape.height
        elif isinstance(shape, Circle):
            return 3.14 * shape.radius ** 2
        # Добавление нового типа требует изменения этого метода
```

**Решение**

Использовать полиморфизм и абстракции:
```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self) -> float:
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self) -> float:
        return 3.14 * self.radius ** 2

class AreaCalculator:
    def calculate(self, shape: Shape) -> float:
        return shape.area()
```

Теперь добавление нового типа (например, Triangle) не требует изменения AreaCalculator.

**Стратегии**

- Наследование и полиморфизм
- Композиция с интерфейсами
- Стратегия-паттерн
- Декоратор-паттерн

#### L — Liskov Substitution Principle (Принцип подстановки Лисков)

**Что это**

Объекты подклассов должны **заменять объекты базового класса** без нарушения функциональности программы.

**Проблема**

Подкласс нарушает контракт базового класса:
```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def set_width(self, width):
        self.width = width
    
    def set_height(self, height):
        self.height = height

class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # Нарушение: квадрат меняет и ширину, и высоту
    
    def set_height(self, height):
        self.width = height
        self.height = height

def test_rectangle(rect: Rectangle):
    rect.set_width(5)
    rect.set_height(4)
    assert rect.width == 5 and rect.height == 4  # Упадет для Square!

test_rectangle(Square(1, 1))  # Нарушение LSP
```

**Решение**

Не наследовать Square от Rectangle, если они ведут себя по-разному. Использовать композицию или общий интерфейс:
```python
class Shape:
    def area(self) -> float:
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self) -> float:
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side
    
    def area(self) -> float:
        return self.side ** 2
```

**Правила для соблюдения LSP**

- Предусловия подкласса не должны быть сильнее, чем у базового класса
- Постусловия подкласса не должны быть слабее, чем у базового класса
- Инварианты базового класса должны сохраняться в подклассе
- Подкласс не должен выбрасывать исключения, которых нет в базовом классе

#### I — Interface Segregation Principle (Принцип разделения интерфейса)

**Что это**

Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше много специфичных интерфейсов, чем один общий.

**Проблема**

Интерфейс заставляет реализовывать методы, которые не нужны:
```python
class Worker:
    def work(self):
        pass
    
    def eat(self):
        pass

class Human(Worker):
    def work(self):
        print("Человек работает")
    
    def eat(self):
        print("Человек ест")

class Robot(Worker):
    def work(self):
        print("Робот работает")
    
    def eat(self):
        raise NotImplementedError("Робот не ест!")  # Принудительная реализация ненужного метода
```

**Решение**

Разделить интерфейс на специфичные:
```python
class Workable:
    def work(self):
        pass

class Eatable:
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        print("Человек работает")
    
    def eat(self):
        print("Человек ест")

class Robot(Workable):
    def work(self):
        print("Робот работает")
```

**Когда применять**

Когда интерфейс становится "толстым" и клиенты реализуют методы, которые им не нужны.

#### D — Dependency Inversion Principle (Принцип инверсии зависимостей)

**Что это**

- Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

**Проблема**

Высокоуровневый модуль зависит от конкретной реализации:
```python
class MySQLDatabase:
    def save(self, data):
        print(f"Сохранение в MySQL: {data}")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Жесткая зависимость от конкретной БД
    
    def create_user(self, name):
        self.db.save(f"User: {name}")
```

Если нужно сменить БД на PostgreSQL, придется менять UserService.

**Решение**

Зависить от абстракции:
```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data: str):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print(f"Сохранение в MySQL: {data}")

class PostgreSQLDatabase(Database):
    def save(self, data):
        print(f"Сохранение в PostgreSQL: {data}")

class UserService:
    def __init__(self, db: Database):  # Зависимость от абстракции
        self.db = db
    
    def create_user(self, name):
        self.db.save(f"User: {name}")

# Использование
mysql_db = MySQLDatabase()
service = UserService(mysql_db)

postgres_db = PostgreSQLDatabase()
service = UserService(postgres_db)  # Легко заменить
```

**Практические техники**

- Dependency Injection (DI): зависимости передаются извне
- Inversion of Control (IoC): контейнер управляет зависимостями
- Factory-паттерн для создания зависимостей

### 1.2 DRY (Don't Repeat Yourself)

**Что это**

Не повторяй код. Если логика дублируется, вынеси ее в одно место.

**Проблема**

Дублирование кода:
```python
def calculate_total_price(items):
    total = 0
    for item in items:
        total += item.price * item.quantity
    return total

def calculate_total_tax(items):
    total = 0
    for item in items:
        total += item.price * item.quantity
    return total * 0.2  # Дублирование логики суммирования
```

**Решение**

Вынести общую логику:
```python
def calculate_subtotal(items):
    return sum(item.price * item.quantity for item in items)

def calculate_total_price(items):
    return calculate_subtotal(items)

def calculate_total_tax(items):
    return calculate_subtotal(items) * 0.2
```

**Когда нарушать DRY**

- Дублирование может быть намеренным, если требования могут разойтись
- Преждевременная абстракция может усложнить код
- Иногда лучше дублирование, чем неправильная абстракция

**Правило трех**

Если код повторяется три раза — пора абстрагировать. До этого можно оставить дублирование.

### 1.3 KISS (Keep It Simple, Stupid)

**Что это**

Делай просто. Простое решение лучше сложного, если оно решает задачу.

**Проблема**

Излишнее усложнение:
```python
class SimpleCalculator:
    def add(self, a, b):
        return a + b

# Не нужно так:
class AdvancedCalculatorFactory:
    def create_calculator(self, strategy):
        if strategy == "addition":
            return AdditionStrategyCalculator()
        # ... для простого сложения
```

**Когда применять**

- Выбирай самое простое решение, которое работает
- Не добавляй абстракции "на будущее"
- Если решение кажется слишком сложным — возможно, есть более простое

**Баланс**

KISS не означает "всегда просто". Иногда сложность оправдана (например, для масштабируемости). Но начинай с простого.

### 1.4 YAGNI (You Aren't Gonna Need It)

**Что это**

Не реализуй функциональность, пока она не нужна. Не добавляй код "на будущее".

**Проблема**

Преждевременная оптимизация и абстракция:
```python
class UserService:
    def __init__(self):
        # Добавили поддержку разных БД, хотя сейчас только MySQL
        self.db_factory = DatabaseFactory()
        self.cache = RedisCache()  # Добавили кеш, хотя не нужен
        self.logger = StructuredLogger()  # Сложное логирование для простой задачи
```

**Решение**

Добавляй только то, что нужно сейчас:
```python
class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Просто и достаточно
    
    def get_user(self, id):
        return self.db.find(id)
```

**Когда нарушать YAGNI**

- Если изменение в будущем будет очень дорогим (например, миграция БД)
- Если есть четкие требования, что функциональность точно понадобится
- Но даже тогда лучше сделать минимально необходимое

## 2) Паттерны проектирования GoF

Паттерны проектирования — это типовые решения часто встречающихся проблем. GoF (Gang of Four) выделили 23 паттерна в трех категориях.

### 2.1 Порождающие паттерны (Creational)

Решают проблемы создания объектов.

#### Singleton (Одиночка)

**Проблема**

Нужен единственный экземпляр класса (например, подключение к БД, логгер, конфигурация).

**Решение**

```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

# Использование
s1 = Singleton()
s2 = Singleton()
assert s1 is s2  # Один и тот же объект
```

**Когда использовать**

- Нужен единственный экземпляр (логирование, конфигурация, пулы соединений)
- Глобальный доступ к этому экземпляру

**Когда не использовать**

- Усложняет тестирование (сложно мокировать)
- Скрывает зависимости
- Нарушает SRP (управление жизненным циклом + бизнес-логика)
- Проблемы с многопоточностью

**Альтернативы**

- Dependency Injection: передавать экземпляр явно
- Модули Python: модуль сам по себе синглтон

#### Factory Method (Фабричный метод)

**Проблема**

Нужно создавать объекты, но точный тип неизвестен на этапе компиляции.

**Решение**

```python
from abc import ABC, abstractmethod

class Transport(ABC):
    @abstractmethod
    def deliver(self):
        pass

class Truck(Transport):
    def deliver(self):
        return "Доставка грузовиком"

class Ship(Transport):
    def deliver(self):
        return "Доставка кораблем"

class Logistics(ABC):
    @abstractmethod
    def create_transport(self) -> Transport:
        pass
    
    def plan_delivery(self):
        transport = self.create_transport()
        return transport.deliver()

class RoadLogistics(Logistics):
    def create_transport(self) -> Transport:
        return Truck()

class SeaLogistics(Logistics):
    def create_transport(self) -> Transport:
        return Ship()

# Использование
logistics = RoadLogistics()
logistics.plan_delivery()  # Создаст Truck
```

**Когда использовать**

- Неизвестен точный тип объекта на этапе компиляции
- Нужна гибкость в создании объектов
- Хочется изолировать код создания от использования

#### Abstract Factory (Абстрактная фабрика)

**Проблема**

Нужно создавать семейства связанных объектов (например, UI-элементы для разных платформ).

**Решение**

```python
from abc import ABC, abstractmethod

class Button(ABC):
    @abstractmethod
    def render(self):
        pass

class WindowsButton(Button):
    def render(self):
        return "Windows кнопка"

class MacButton(Button):
    def render(self):
        return "Mac кнопка"

class Checkbox(ABC):
    @abstractmethod
    def render(self):
        pass

class WindowsCheckbox(Checkbox):
    def render(self):
        return "Windows чекбокс"

class MacCheckbox(Checkbox):
    def render(self):
        return "Mac чекбокс"

class GUIFactory(ABC):
    @abstractmethod
    def create_button(self) -> Button:
        pass
    
    @abstractmethod
    def create_checkbox(self) -> Checkbox:
        pass

class WindowsFactory(GUIFactory):
    def create_button(self) -> Button:
        return WindowsButton()
    
    def create_checkbox(self) -> Checkbox:
        return WindowsCheckbox()

class MacFactory(GUIFactory):
    def create_button(self) -> Button:
        return MacButton()
    
    def create_checkbox(self) -> Checkbox:
        return MacCheckbox()

# Использование
factory = WindowsFactory()
button = factory.create_button()
checkbox = factory.create_checkbox()
```

**Когда использовать**

- Нужно создавать семейства связанных объектов
- Важна совместимость объектов (например, все элементы одной платформы)

### 2.2 Структурные паттерны (Structural)

Решают проблемы композиции объектов.

#### Adapter (Адаптер)

**Проблема**

Нужно использовать класс с неподходящим интерфейсом.

**Решение**

```python
class OldPaymentSystem:
    def process_payment_legacy(self, amount, currency):
        return f"Оплата {amount} {currency} через старую систему"

class NewPaymentInterface:
    def pay(self, amount: float, currency: str) -> str:
        pass

class PaymentAdapter(NewPaymentInterface):
    def __init__(self, old_system: OldPaymentSystem):
        self.old_system = old_system
    
    def pay(self, amount: float, currency: str) -> str:
        return self.old_system.process_payment_legacy(amount, currency)

# Использование
old_system = OldPaymentSystem()
adapter = PaymentAdapter(old_system)
result = adapter.pay(100, "USD")  # Используем новый интерфейс
```

**Когда использовать**

- Интеграция со сторонними библиотеками с неподходящим интерфейсом
- Рефакторинг: постепенный переход на новый интерфейс

#### Decorator (Декоратор)

**Проблема**

Нужно добавлять поведение объектам динамически, без изменения их класса.

**Решение**

```python
from abc import ABC, abstractmethod

class Coffee(ABC):
    @abstractmethod
    def cost(self) -> float:
        pass

class SimpleCoffee(Coffee):
    def cost(self) -> float:
        return 2.0

class CoffeeDecorator(Coffee):
    def __init__(self, coffee: Coffee):
        self._coffee = coffee
    
    def cost(self) -> float:
        return self._coffee.cost()

class MilkDecorator(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 0.5

class SugarDecorator(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 0.2

# Использование
coffee = SimpleCoffee()
coffee = MilkDecorator(coffee)
coffee = SugarDecorator(coffee)
print(coffee.cost())  # 2.7
```

**Когда использовать**

- Нужно добавлять поведение объектам динамически
- Наследование не подходит (слишком много комбинаций)
- Хочется соблюсти Open/Closed Principle

#### Facade (Фасад)

**Проблема**

Сложная подсистема с множеством классов. Нужен простой интерфейс.

**Решение**

```python
class CPU:
    def start(self):
        return "CPU запущен"

class Memory:
    def load(self):
        return "Память загружена"

class HardDrive:
    def read(self):
        return "Диск прочитан"

class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hard_drive = HardDrive()
    
    def start_computer(self):
        results = []
        results.append(self.cpu.start())
        results.append(self.memory.load())
        results.append(self.hard_drive.read())
        return " | ".join(results)

# Использование
computer = ComputerFacade()
computer.start_computer()  # Простой интерфейс вместо работы с тремя классами
```

**Когда использовать**

- Нужен простой интерфейс для сложной подсистемы
- Хочется уменьшить связанность клиента с подсистемой

### 2.3 Поведенческие паттерны (Behavioral)

Решают проблемы взаимодействия объектов.

#### Strategy (Стратегия)

**Проблема**

Нужно выбирать алгоритм во время выполнения.

**Решение**

```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> str:
        pass

class CreditCardStrategy(PaymentStrategy):
    def pay(self, amount: float) -> str:
        return f"Оплата {amount} кредитной картой"

class PayPalStrategy(PaymentStrategy):
    def pay(self, amount: float) -> str:
        return f"Оплата {amount} через PayPal"

class PaymentContext:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy
    
    def set_strategy(self, strategy: PaymentStrategy):
        self._strategy = strategy
    
    def execute_payment(self, amount: float) -> str:
        return self._strategy.pay(amount)

# Использование
context = PaymentContext(CreditCardStrategy())
context.execute_payment(100)

context.set_strategy(PayPalStrategy())
context.execute_payment(200)
```

**Когда использовать**

- Есть несколько способов выполнить задачу
- Нужно выбирать алгоритм во время выполнения
- Хочется избежать условных операторов (if/else для выбора алгоритма)

#### Observer (Наблюдатель)

**Проблема**

Объекты должны уведомляться об изменениях в другом объекте.

**Решение**

```python
from abc import ABC, abstractmethod

class Observer(ABC):
    @abstractmethod
    def update(self, message: str):
        pass

class Subject:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer: Observer):
        self._observers.append(observer)
    
    def detach(self, observer: Observer):
        self._observers.remove(observer)
    
    def notify(self, message: str):
        for observer in self._observers:
            observer.update(message)

class EmailObserver(Observer):
    def update(self, message: str):
        print(f"Email: {message}")

class SMSObserver(Observer):
    def update(self, message: str):
        print(f"SMS: {message}")

# Использование
subject = Subject()
subject.attach(EmailObserver())
subject.attach(SMSObserver())
subject.notify("Заказ создан")
```

**Когда использовать**

- Нужна слабая связанность между объектами
- Изменения в одном объекте должны уведомлять множество других
- Неизвестно заранее, сколько объектов нужно уведомить

#### Command (Команда)

**Проблема**

Нужно инкапсулировать запрос как объект, чтобы параметризовать клиентов разными запросами, ставить в очередь, логировать, отменять.

**Решение**

```python
from abc import ABC, abstractmethod

class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

class Light:
    def __init__(self):
        self.is_on = False
    
    def turn_on(self):
        self.is_on = True
        return "Свет включен"
    
    def turn_off(self):
        self.is_on = False
        return "Свет выключен"

class LightOnCommand(Command):
    def __init__(self, light: Light):
        self.light = light
    
    def execute(self):
        return self.light.turn_on()
    
    def undo(self):
        return self.light.turn_off()

class LightOffCommand(Command):
    def __init__(self, light: Light):
        self.light = light
    
    def execute(self):
        return self.light.turn_off()
    
    def undo(self):
        return self.light.turn_on()

class RemoteControl:
    def __init__(self):
        self.command = None
    
    def set_command(self, command: Command):
        self.command = command
    
    def press_button(self):
        if self.command:
            return self.command.execute()
    
    def press_undo(self):
        if self.command:
            return self.command.undo()

# Использование
light = Light()
remote = RemoteControl()

remote.set_command(LightOnCommand(light))
remote.press_button()

remote.set_command(LightOffCommand(light))
remote.press_button()
remote.press_undo()  # Отмена
```

**Когда использовать**

- Нужна очередь команд
- Нужна отмена операций (undo/redo)
- Нужно логировать запросы
- Нужно параметризовать объекты операциями

## 3) Архитектурные паттерны

Паттерны на уровне архитектуры приложения.

### 3.1 MVC (Model-View-Controller)

**Что это**

Разделение приложения на три компонента:
- **Model**: данные и бизнес-логика
- **View**: представление (UI)
- **Controller**: обработка ввода, координация Model и View

**Поток данных**

```
User → Controller → Model → View → User
```

**Пример**

```python
class UserModel:
    def __init__(self):
        self.users = []
    
    def add_user(self, name):
        self.users.append(name)
        return self.users

class UserView:
    def show_users(self, users):
        print(f"Пользователи: {', '.join(users)}")
    
    def get_user_input(self):
        return input("Введите имя: ")

class UserController:
    def __init__(self, model: UserModel, view: UserView):
        self.model = model
        self.view = view
    
    def add_user(self):
        name = self.view.get_user_input()
        users = self.model.add_user(name)
        self.view.show_users(users)
```

**Когда использовать**

- Веб-приложения (Django, Rails)
- Desktop-приложения
- Нужно разделить логику и представление

### 3.2 Repository

**Что это**

Абстракция над хранилищем данных. Клиент работает с коллекцией объектов, не зная деталей БД.

**Пример**

```python
from abc import ABC, abstractmethod

class User:
    def __init__(self, id, name):
        self.id = id
        self.name = name

class UserRepository(ABC):
    @abstractmethod
    def find_by_id(self, id: int) -> User:
        pass
    
    @abstractmethod
    def save(self, user: User):
        pass

class InMemoryUserRepository(UserRepository):
    def __init__(self):
        self._users = {}
    
    def find_by_id(self, id: int) -> User:
        return self._users.get(id)
    
    def save(self, user: User):
        self._users[user.id] = user

class DatabaseUserRepository(UserRepository):
    def find_by_id(self, id: int) -> User:
        # SQL запрос
        pass
    
    def save(self, user: User):
        # SQL запрос
        pass

class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository
    
    def get_user(self, id: int) -> User:
        return self.repository.find_by_id(id)
```

**Когда использовать**

- Нужна абстракция над хранилищем данных
- Хочется легко тестировать без БД
- Нужно легко менять способ хранения

### 3.3 CQRS (Command Query Responsibility Segregation)

**Что это**

Разделение операций на команды (изменяют состояние) и запросы (читают данные). Могут использовать разные модели данных.

**Пример**

```python
class WriteModel:
    def create_user(self, name: str):
        # Запись в БД для записи
        pass

class ReadModel:
    def get_user(self, id: int):
        # Чтение из БД для чтения (может быть другая БД или кеш)
        pass

class UserCommandHandler:
    def __init__(self, write_model: WriteModel):
        self.write_model = write_model
    
    def handle_create_user(self, name: str):
        self.write_model.create_user(name)

class UserQueryHandler:
    def __init__(self, read_model: ReadModel):
        self.read_model = read_model
    
    def handle_get_user(self, id: int):
        return self.read_model.get_user(id)
```

**Когда использовать**

- Высокая нагрузка на чтение и запись
- Нужна оптимизация чтения (другая структура данных)
- Сложные требования к производительности

## Как выбирать паттерн

1. **Понять проблему**: что именно нужно решить?
2. **Проверить принципы**: не нарушаем ли SOLID, DRY, KISS, YAGNI?
3. **Выбрать паттерн**: какой паттерн решает похожую проблему?
4. **Не переусложнять**: если простое решение работает — используй его

## Анти-паттерны

- **Золотой молоток**: применять один паттерн везде
- **Преждевременная оптимизация**: добавлять паттерны "на будущее"
- **Over-engineering**: усложнять там, где не нужно

## Мини-ответы "как на экзамене"

- **Что такое SOLID**: пять принципов ООП: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. Помогают писать поддерживаемый код.

- **Когда использовать Factory Method**: когда точный тип объекта неизвестен на этапе компиляции, нужна гибкость в создании объектов.

- **Чем Adapter отличается от Facade**: Adapter меняет интерфейс одного класса на другой. Facade упрощает интерфейс сложной подсистемы.

- **Что такое Strategy**: паттерн, который инкапсулирует алгоритм в отдельный класс. Позволяет выбирать алгоритм во время выполнения.

- **Когда использовать Repository**: когда нужна абстракция над хранилищем данных, чтобы легко тестировать и менять способ хранения.
