"""
Задание: Максимальная глубина бинарного дерева

Условие задачи:
  Дан корень бинарного дерева. Вычисли максимальную глубину дерева — длину самого длинного
  пути от корня до листа (количество узлов на пути или количество уровней — уточни в формулировке).
  Пустое дерево (root is None) имеет глубину 0.

Что такое бинарное дерево:
  Структура из узлов. У каждого узла есть значение (val) и не более двух детей: левый (left) и правый (right).
  У листа оба ребёнка равны None. Корень — единственный узел, на который никто не ссылается.
  Пример: корень 3, у него left=9, right=20. У 9 детей нет (лист). У 20 есть left=15, right=7.

Что такое глубина:
  Глубина узла — число рёбер от корня до этого узла. Глубина корня = 0, его детей = 1, внуков = 2 и т.д.
  Максимальная глубина дерева — глубина самого глубокого листа (или «высота» дерева: сколько уровней).
  Часто в задаче считают «количество узлов на пути»: тогда корень = 1, его дети = 2 — в таком случае
  ответ на один больше. В примере ниже считаем по уровням: корень уровень 1, его дети уровень 2, их дети уровень 3.

Пример дерева (в нотации LeetCode [корень, левый, правый, …]):
  [3, 9, 20, null, null, 15, 7] — корень 3, левый ребёнок 9 (без детей), правый 20 с детьми 15 и 7.
  Уровни: 1 — 3; 2 — 9, 20; 3 — 15, 7. Максимальная глубина (число уровней) = 3.

На вход функции: корень (узел с полями .val, .left, .right). Для пустого дерева передают None.
На выход: число — максимальная глубина (или высота) дерева.

Как делать (подсказка):

  Вариант 1 — рекурсия:
    1) База: если root is None — вернуть 0.
    2) Рекуррентно: глубина дерева с корнем root = 1 + max(глубина левого поддерева, глубина правого поддерева).
    3) Вызови себя от root.left и root.right, возьми максимум из двух чисел, прибавь 1 и верни.

  Вариант 2 — BFS по уровням:
    BFS (Breadth-First Search) — обход в ширину: сначала все узлы одного уровня, потом следующий уровень.
    Используется очередь (FIFO): кладём детей в конец, достаём из начала. Так узлы обрабатываются по уровням.
    1) Очередь (deque), изначально в ней только корень. Счётчик уровней = 0.
    2) Пока очередь не пуста: взять размер текущего уровня (len(очередь)), вытащить столько узлов, добавить в очередь их непустых детей, счётчик уровней += 1.
    3) Вернуть счётчик уровней.
"""

from collections import deque
from dataclasses import dataclass


@dataclass
class Node():
    val: int
    left: "Node | None"
    right: "Node | None"


def find_depth(root: Node | None) -> int:
    if root is None:
        return 0
    return 1 + max(find_depth(root.left), find_depth(root.right))


def bfs(root: Node | None) -> int:

    if root is None:
        return 0

    q: deque[Node] = deque([root])
    depth = 0

    while q:
        for _ in range(len(q)):
            node = q.popleft()
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        depth += 1
    return depth
