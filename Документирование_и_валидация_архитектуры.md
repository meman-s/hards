# Документирование и валидация архитектуры — подробный конспект

Этот конспект сделан по пункту из файла `Список тяжелых навыков - Степан.xlsx` → **Проектирование** → **Документирование и валидация**:

- Architectural Decision Records (ADR)
- MVP / PoC / Прототип

Цель: понимать **как документировать архитектурные решения**, **когда использовать MVP/PoC/Прототип**, **как валидировать архитектуру**, **что фиксировать и зачем**.

## Общая рамка: зачем документировать архитектуру

Архитектурная документация помогает:
- **Понимать систему**: новым членам команды, стейкхолдерам
- **Принимать решения**: не повторять обсуждения, понимать контекст прошлых решений
- **Эволюционировать**: видеть, что менялось и почему
- **Валидировать**: проверять, соответствует ли реализация задумке

Важно: документация должна быть **живой** (обновляться) и **полезной** (отвечать на реальные вопросы).

## 1) Architectural Decision Records (ADR)

### 1.1 Что это

ADR — это документ, который фиксирует **важное архитектурное решение**, принятое в проекте: что решили, почему, какие были альтернативы, последствия.

**Ключевая идея**: не документировать "как устроена система", а документировать **"почему система устроена именно так"**.

### 1.2 Формат ADR

Типичная структура ADR:

```markdown
# ADR-001: Использование PostgreSQL вместо MySQL

## Статус
Принято

## Контекст
Нужно выбрать БД для нового проекта. Требования:
- ACID-транзакции
- Поддержка JSON
- Хорошая производительность на чтение

## Решение
Используем PostgreSQL.

## Последствия

### Положительные
- Нативная поддержка JSON (jsonb)
- Расширяемость (расширения)
- Хорошая производительность
- Активное сообщество

### Отрицательные
- Меньше готовых решений для репликации, чем у MySQL
- Команда больше знакома с MySQL (нужно обучение)

## Альтернативы

### MySQL
- Плюсы: команда знакома, много готовых решений
- Минусы: слабее поддержка JSON, меньше возможностей расширения
- Почему не выбрали: JSON — критичное требование

### MongoDB
- Плюсы: отличная поддержка JSON, горизонтальное масштабирование
- Минусы: нет ACID-транзакций (на момент решения), команда не знакома
- Почему не выбрали: ACID — обязательное требование
```

### 1.3 Когда создавать ADR

Создавай ADR для решений, которые:
- **Трудно отменить**: выбор технологии, архитектурного стиля, способа интеграции
- **Влияют на команду**: меняют процесс разработки, требуют обучения
- **Имеют последствия**: влияют на производительность, масштабируемость, стоимость
- **Вызывают споры**: были альтернативы, нужно зафиксировать обоснование

**Не создавай ADR для**:
- Очевидных решений без альтернатив
- Временных решений (прототипы, эксперименты)
- Мелких технических деталей (выбор имени переменной)

### 1.4 Структура ADR (детально)

#### Заголовок
`ADR-XXX: Краткое описание решения`

Нумерация: последовательная (001, 002, 003) или по дате (2024-01-15-use-postgresql).

#### Статус
- **Предложено**: решение предложено, но не принято
- **Принято**: решение принято и реализуется
- **Отклонено**: решение не принято (с указанием причины)
- **Заменено**: решение заменено другим ADR (ссылка на новый)

#### Контекст
**Что здесь писать**:
- Проблема, которую нужно решить
- Ограничения (технические, бизнес, временные)
- Требования, которые влияют на решение
- Текущая ситуация

**Пример**:
```
Проект растет, монолитная архитектура становится узким местом:
- Разные части системы имеют разные требования к масштабированию
- Команда выросла до 15 разработчиков, сложно координировать работу
- Нужна возможность независимого развертывания компонентов
- Бюджет позволяет инвестировать в инфраструктуру
```

#### Решение
**Что здесь писать**:
- Что именно решили сделать
- Ключевые детали реализации (без излишней детализации)
- Ссылки на документацию, если нужно

**Пример**:
```
Переходим на микросервисную архитектуру:
- Выделяем сервисы по доменам (User Service, Order Service, Payment Service)
- Используем REST API для синхронной коммуникации
- Используем RabbitMQ для асинхронных событий
- Каждый сервис имеет свою БД
- Используем Kubernetes для оркестрации
```

#### Последствия
**Что здесь писать**:
- Положительные последствия (что получаем)
- Отрицательные последствия (риски, компромиссы)
- Влияние на команду, процессы, инфраструктуру
- Метрики, если применимо (производительность, стоимость)

**Пример**:
```
Положительные:
- Независимое развертывание сервисов
- Команды могут работать параллельно
- Масштабирование отдельных сервисов
- Технологическая гибкость

Отрицательные:
- Усложнение операций (мониторинг, логирование)
- Сетевое взаимодействие (latency, надежность)
- Управление данными (транзакции, согласованность)
- Нужны DevOps-навыки в команде
```

#### Альтернативы
**Что здесь писать**:
- Какие варианты рассматривали
- Плюсы и минусы каждого
- Почему не выбрали

**Пример**:
```
Модульный монолит:
- Плюсы: проще операции, проще транзакции
- Минусы: все еще одно развертывание, сложнее масштабирование
- Почему не выбрали: нужна независимость развертывания

SOA с ESB:
- Плюсы: централизованное управление, стандартизация
- Минусы: ESB становится узким местом, сложность
- Почему не выбрали: хотим избежать централизованного компонента
```

### 1.5 Где хранить ADR

Типичные варианты:
- **В репозитории**: папка `docs/adr/` или `architecture/decisions/`
- **В wiki**: Confluence, Notion, если команда использует
- **В отдельном репозитории**: если решений много и они общие для нескольких проектов

**Рекомендация**: хранить в репозитории рядом с кодом, чтобы:
- Решения были рядом с реализацией
- История изменений видна в git
- Легко найти через поиск

### 1.6 Управление ADR

#### Обновление ADR
ADR можно обновлять, если:
- Появилась новая информация о последствиях
- Решение изменилось (тогда создать новый ADR со статусом "Заменено")
- Статус изменился (например, "Предложено" → "Принято")

#### Связывание ADR
ADR могут ссылаться друг на друга:
- Если решение зависит от предыдущего
- Если решение заменяет предыдущее
- Если есть конфликтующие решения

#### Ревизия ADR
Периодически (раз в квартал/полгода) просматривать ADR:
- Актуальны ли решения?
- Реализованы ли последствия?
- Нужно ли обновить статус?

### 1.7 Примеры ADR

#### ADR-001: Выбор языка программирования
```
# ADR-001: Использование Python для backend

## Статус
Принято

## Контекст
Нужно выбрать язык для нового backend-проекта. Команда знакома с Python и JavaScript.

## Решение
Используем Python 3.11+ с FastAPI.

## Последствия
Положительные:
- Команда знакома с языком
- Быстрая разработка
- Богатая экосистема библиотек

Отрицательные:
- Производительность ниже, чем у Go/Rust (но достаточна для проекта)
- GIL ограничивает параллелизм (но async решает большинство случаев)

## Альтернативы
- Node.js: команда знакома, но Python лучше для data processing (требование проекта)
- Go: выше производительность, но команда не знакома, медленнее разработка
```

#### ADR-002: Выбор архитектурного стиля
```
# ADR-002: Гексагональная архитектура для domain layer

## Статус
Принято

## Контекст
Проект будет долгоживущим, нужна гибкость в замене технологий (БД, внешние API).

## Решение
Используем гексагональную архитектуру:
- Domain layer: бизнес-логика, интерфейсы репозиториев
- Application layer: use cases
- Infrastructure layer: реализации репозиториев, контроллеры

## Последствия
Положительные:
- Независимость домена от фреймворков
- Легкое тестирование бизнес-логики
- Гибкость в замене технологий

Отрицательные:
- Больше абстракций, больше кода
- Нужна дисциплина команды (не нарушать правила зависимостей)

## Альтернативы
- Монолитная структура: проще, но привязка к фреймворку
- Чистая архитектура: похоже, но гексагональная проще для команды
```

### 1.8 Практические советы

- **Начинай с малого**: не нужно документировать каждое решение сразу. Начни с самых важных.
- **Используй шаблоны**: создай шаблон ADR, чтобы команда знала формат.
- **Регулярно обновляй**: ADR должны быть актуальными.
- **Связывай с кодом**: в коде можно оставлять ссылки на ADR для важных решений.
- **Не переусложняй**: ADR должен быть понятным и полезным, а не формальностью.

## 2) MVP / PoC / Прототип

### 2.1 Общая рамка: зачем нужны

Перед полной реализацией архитектуры часто нужно:
- **Проверить гипотезу**: работает ли идея технически/бизнесово?
- **Снизить риски**: понять сложность, оценить затраты
- **Получить обратную связь**: от пользователей, стейкхолдеров
- **Принять решение**: стоит ли инвестировать в полную реализацию?

MVP, PoC и Прототип — это разные инструменты для разных целей.

### 2.2 PoC (Proof of Concept) — Доказательство концепции

**Что это**

Минимальная реализация, которая **доказывает, что идея технически реализуема**.

**Цель**: ответить на вопрос "Можем ли мы это сделать технически?"

**Характеристики**:
- **Очень ограниченный функционал**: только ключевая техническая часть
- **Быстрая разработка**: дни или недели
- **Одноразовое использование**: обычно не развивается дальше
- **Фокус на техническом риске**: интеграция, производительность, сложный алгоритм

**Примеры**:
- Проверить, можно ли интегрироваться с внешним API
- Проверить производительность алгоритма на больших данных
- Проверить, работает ли новая технология в нашем стеке
- Проверить, можно ли мигрировать данные без простоя

**Когда использовать**:
- Есть **технический риск**: неясно, возможно ли решение
- Нужно **оценить сложность** перед полной реализацией
- Нужно **выбрать технологию**: сравнить варианты
- Нужно **убедить стейкхолдеров**: показать, что технически возможно

**Что не делать**:
- Не делать PoC для очевидных вещей (например, CRUD)
- Не делать PoC вместо планирования (если риски понятны, планируй сразу)
- Не развивать PoC в продакшн (PoC обычно одноразовый)

**Пример PoC**:

Задача: проверить, можно ли обрабатывать 1M запросов в секунду.

PoC:
- Простой endpoint, который возвращает статический ответ
- Нагрузочное тестирование
- Измерение производительности
- Вывод: да, технически возможно с текущим стеком

Результат: решение о том, стоит ли инвестировать в полную реализацию.

### 2.3 Прототип (Prototype)

**Что это**

Рабочая модель системы или части системы, которая **демонстрирует функциональность и UX**.

**Цель**: ответить на вопросы "Как это будет работать?" и "Как это будет выглядеть?"

**Характеристики**:
- **Визуальная/интерактивная демонстрация**: можно "пощупать"
- **Может быть нефункциональным**: только UI без backend, или наоборот
- **Быстрая разработка**: недели
- **Одноразовое или эволюционное**: может выбросить или развить

**Типы прототипов**:

1. **Low-fidelity (Lo-Fi)**: наброски, wireframes, бумажные прототипы
   - Цель: быстро проверить идею
   - Время: часы-дни

2. **High-fidelity (Hi-Fi)**: интерактивный прототип, близкий к финальному виду
   - Цель: проверить UX, получить обратную связь
   - Время: дни-недели

3. **Технический прототип**: рабочая часть системы (например, только backend)
   - Цель: проверить архитектуру, интеграции
   - Время: недели

**Когда использовать**:
- Нужно **проверить UX**: удобно ли пользователям?
- Нужно **получить обратную связь** от стейкхолдеров
- Нужно **продемонстрировать идею** инвесторам/заказчикам
- Нужно **проверить архитектуру**: работает ли выбранный подход?

**Что не делать**:
- Не делать прототип, если требования ясны и нет рисков
- Не путать прототип с MVP (прототип — демонстрация, MVP — работающий продукт)

**Пример прототипа**:

Задача: новый интерфейс для управления заказами.

Прототип:
- Интерактивный UI-прототип (Figma, HTML/CSS/JS)
- Показывает основные экраны и переходы
- Нет реального backend, данные мокированные
- Показываем пользователям, собираем обратную связь

Результат: понимание, что нужно изменить в UX перед разработкой.

### 2.4 MVP (Minimum Viable Product) — Минимально жизнеспособный продукт

**Что это**

Рабочая версия продукта с **минимальным набором функций**, которая **решает проблему пользователя** и может быть **выпущена в продакшн**.

**Цель**: ответить на вопрос "Нужен ли этот продукт пользователям?" и получить обратную связь для дальнейшего развития.

**Характеристики**:
- **Рабочий продукт**: можно использовать в реальных условиях
- **Минимальный функционал**: только самое необходимое для решения проблемы
- **Качественная реализация**: код должен быть поддерживаемым (не "быстрый костыль")
- **Выпускается в продакшн**: реальные пользователи, реальные данные

**Ключевое отличие от PoC/Прототипа**:
- PoC доказывает техническую возможность
- Прототип демонстрирует идею
- **MVP — это работающий продукт**, который решает проблему

**Что включать в MVP**:
- **Критический путь**: основной сценарий использования от начала до конца
- **Без "nice to have"**: только то, без чего продукт не работает
- **Качество важнее количества**: лучше сделать меньше, но хорошо

**Что не включать в MVP**:
- Дополнительные функции "на будущее"
- Оптимизации, которые не критичны
- Интеграции, которые не обязательны для основного сценария

**Когда использовать**:
- Нужно **быстро выйти на рынок** и получить обратную связь
- **Неясны требования**: нужно проверить гипотезу о потребностях пользователей
- **Ограниченные ресурсы**: нужно сфокусироваться на главном
- **Итеративная разработка**: MVP — первая итерация, потом расширяем

**Риски MVP**:
- **Переоценка "минимальности"**: включают слишком много
- **Недооценка качества**: делают "костыли", которые потом сложно переделать
- **Нет плана развития**: MVP остается MVP, не развивается

**Пример MVP**:

Задача: сервис доставки еды.

MVP:
- Регистрация пользователя
- Просмотр ресторанов (5-10 ресторанов, статичный список)
- Создание заказа
- Оплата (один способ оплаты)
- Уведомление ресторану (email)

Не в MVP:
- Рейтинги и отзывы
- Промокоды
- Разные способы оплаты
- Мобильное приложение
- Интеграция с множеством ресторанов

Результат: проверка гипотезы, обратная связь, понимание приоритетов для следующих итераций.

### 2.5 Сравнение PoC, Прототипа и MVP

| Критерий | PoC | Прототип | MVP |
|---|---|---|---|
| **Цель** | Доказать техническую возможность | Демонстрировать идею/UX | Решить проблему пользователя |
| **Аудитория** | Техническая команда, стейкхолдеры | Пользователи, стейкхолдеры | Реальные пользователи |
| **Функциональность** | Только ключевая техническая часть | Может быть частичной | Полный критический путь |
| **Качество кода** | Не важно (одноразовое) | Не важно (может быть демо) | Важно (продакшн) |
| **Время разработки** | Дни-недели | Недели | Недели-месяцы |
| **Использование** | Одноразовое | Демонстрация/выброс | Продакшн, развитие |
| **Риск** | Технический | UX/требования | Бизнес/рынок |

### 2.6 Когда что использовать: decision tree

1. **Есть технический риск?** (неясно, возможно ли решение)
   - Да → **PoC**
   - Нет → следующий вопрос

2. **Нужно проверить UX/требования?** (неясно, что нужно пользователям)
   - Да → **Прототип** (для UX) или **MVP** (для проверки гипотезы на рынке)
   - Нет → следующий вопрос

3. **Нужно быстро выйти на рынок?** (проверить бизнес-гипотезу)
   - Да → **MVP**
   - Нет → полная разработка

### 2.7 Валидация архитектуры через PoC/Прототип/MVP

**PoC для валидации архитектуры**:
- Проверить производительность выбранной архитектуры
- Проверить сложность интеграций
- Оценить операционную сложность

**Прототип для валидации архитектуры**:
- Проверить, работает ли выбранный подход на практике
- Оценить сложность разработки

**MVP для валидации архитектуры**:
- Проверить, масштабируется ли архитектура под нагрузкой
- Проверить, справляется ли архитектура с реальными требованиями
- Получить данные для оптимизации

### 2.8 Практические советы

- **Не путать цели**: PoC — технический риск, Прототип — демонстрация, MVP — работающий продукт
- **Не развивать PoC в продакшн**: PoC обычно одноразовый, для продакшна нужна нормальная реализация
- **MVP должен быть качественным**: код должен быть поддерживаемым, не "костыли"
- **Планировать развитие**: MVP — первая итерация, нужен план следующих шагов
- **Измерять результаты**: PoC/Прототип/MVP должны давать измеримые результаты для принятия решений

## Мини-ответы "как на экзамене"

- **Что такое ADR**: документ, который фиксирует важное архитектурное решение: что решили, почему, альтернативы, последствия. Помогает не повторять обсуждения и понимать контекст решений.

- **Когда создавать ADR**: для решений, которые трудно отменить, влияют на команду, имеют последствия, вызывали споры. Не для очевидных или временных решений.

- **Чем PoC отличается от MVP**: PoC доказывает техническую возможность (одноразовый, не в продакшн). MVP — работающий продукт, который решает проблему пользователя (в продакшне, развивается).

- **Когда использовать прототип**: когда нужно проверить UX, получить обратную связь от пользователей, продемонстрировать идею. Прототип — демонстрация, не обязательно рабочий продукт.

- **Что должно быть в MVP**: критический путь использования продукта от начала до конца, только самое необходимое для решения проблемы. Без дополнительных функций "на будущее".
