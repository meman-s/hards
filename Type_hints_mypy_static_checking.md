# Type hints, mypy и статическая проверка типов в Python

## 1. Зачем нужны типы в Python

Python — язык с **динамической типизацией**: тип переменной определяется в runtime. Это даёт гибкость, но и риски: опечатки в именах, передача не того типа в функцию, ошибки обнаруживаются только при запуске.

**Статическая проверка типов** — анализ кода без запуска, на этапе разработки. Цели:
- раньше находить ошибки (до тестов и продакшена);
- улучшать читаемость и документацию кода (типы как контракт);
- лучше поддерживать рефакторинг и автодополнение в IDE.

Типы в Python **не меняют поведение** интерпретатора: это аннотации для инструментов и людей.

---

## 2. Type hints (аннотации типов)

### 2.1 Синтаксис

Аннотации задаются через двоеточие для переменных/параметров и `->` для возвращаемого значения функции.

```python
def greet(name: str) -> str:
    return f"Hello, {name}"

x: int = 42
items: list[str] = []
```

Аннотации **не обязательны** и **не проверяются** самим интерпретатором при выполнении (за исключением редкого использования `annotations` в коде).

### 2.2 Встроенные типы

- **Простые:** `int`, `float`, `str`, `bool`, `bytes`, `None`
- **Коллекции:** `list[Elem]`, `dict[Key, Value]`, `set[Elem]`, `tuple[Elem, ...]` или `tuple[E1, E2]`
- **Специальные:** `None` (часто в связке с `Optional`), `Any` (любой тип, отключает проверку)

В Python 3.9+ встроенные коллекции можно писать как `list[str]`; в 3.8 и раньше — `List[str]` из `typing`.

### 2.3 typing — основные конструкции

- **`Optional[T]`** — то же, что `T | None` (Python 3.10+): значение типа `T` или `None`.
- **`Union[A, B]`** — то же, что `A | B`: значение одного из типов.
- **`Any`** — любой тип; статический анализатор почти не проверяет.
- **`Callable[[Arg1, Arg2], Return]`** — тип функции (аргументы и возврат).
- **`TypeVar`** — переменная типа для обобщённого (generic) кода.
- **`Generic[T]`** — базовый класс для generic-классов.
- **`Literal["a", "b"]`** — только указанные литеральные значения.
- **`Final`** — константа (не должна переназначаться).
- **`TypedDict`** — словарь с фиксированными ключами и типами значений.
- **`Protocol`** — структурная типизация (как интерфейсы).

### 2.4 Примеры

```python
from typing import Optional, Callable, Union

def find(lst: list[str], x: str) -> Optional[int]:
    for i, v in enumerate(lst):
        if v == x:
            return i
    return None

def apply(f: Callable[[int], str], n: int) -> str:
    return f(n)

def parse_id(value: Union[str, int]) -> int:
    return int(value)
```

---

## 3. mypy

**mypy** — статический анализатор типов для Python. Читает аннотации и сообщает о несоответствиях типов, не запуская код.

### 3.1 Установка и запуск

```bash
pip install mypy
mypy script.py
mypy src/
```

### 3.2 Что проверяет mypy

- Совпадение типов аргументов и возвращаемых значений с аннотациями.
- Существование атрибутов и методов у объектов.
- Несоответствие типов при присваивании и в коллекциях.
- Частично — корректность использования `Optional`/`None`.

### 3.3 Режимы строгости

- **По умолчанию:** часть проверок отключена (например, не все функции обязаны иметь аннотации).
- **`--strict`** — максимально строгий режим (обязательные аннотации, запрет необработанного `Any` и т.д.).
- В конфиге можно включать отдельные проверки: `disallow_untyped_defs`, `check_untyped_defs`, `warn_return_any` и др.

### 3.4 Конфигурация

Файл **`mypy.ini`** или **`pyproject.toml`** (секция `[tool.mypy]`):

```ini
[mypy]
python_version = 3.11
strict = true
warn_return_any = true
warn_unused_ignores = true
```

Можно задавать разные опции для модулей:

```ini
[mypy-tests.*]
disallow_untyped_defs = false
```

### 3.5 Игнорирование

- Строка: `# type: ignore` или `# type: ignore[code]`.
- Файл: в конфиге `[[tool.mypy.overrides]]` с `ignore` для путей.

Игнор стоит использовать точечно, когда тип корректно выразить сложно или это сторонняя библиотека без типов.

---

## 4. Статическая проверка типов (общая теория)

### 4.1 Статическая vs динамическая типизация

- **Динамическая:** типы проверяются во время выполнения (Python по умолчанию).
- **Статическая:** типы проверяются до выполнения (компилятор/анализатор). В Python это делают mypy, Pyright, Pyre и др.

Python остаётся динамическим; статическая проверка — дополнительный слой.

### 4.2 Номинальная и структурная типизация

- **Номинальная:** совместимость по имени типа (как в Java, C++). В Python наследование даёт номинальную совместимость.
- **Структурная:** совместимость по наличию полей/методов (`Protocol` в Python — «утиная типизация» для статического анализатора).

### 4.3 Duck typing и типы

«Если оно крякает как утка — это утка.» В runtime Python не смотрит на аннотации; типы нужны для статического анализа и документации, не для изменения поведения.

### 4.4 Другие инструменты

- **Pyright** (Pylance в VS Code) — быстрый, часто используется в редакторах.
- **Pyre** (Meta) — строгая проверка.
- **pytype** (Google) — допускает частично нетипизированный код.

Они по-разному обрабатывают одни и те же аннотации; стиль аннотаций обычно совместим (PEP 484, typing).

---

## 5. Важные концепции для экзамена

| Концепция | Кратко |
|-----------|--------|
| Type hint | Аннотация типа (для переменной, аргумента, возврата), не выполняется интерпретатором |
| Optional[T] | T или None |
| Union[A, B] / A \| B | Значение типа A или B |
| Any | Любой тип, проверка по сути отключена |
| mypy | Статический анализатор типов для Python по PEP 484 |
| Статическая проверка | Анализ типов без запуска программы |
| Dynamic typing | Типы в Python проверяются в runtime; аннотации на это не влияют |
| Generic (TypeVar, Generic) | Обобщённые типы, например list[T], чтобы не терять точность типа |
| Protocol | Структурный подтип: «всё, у чего есть такие методы» |
| TypedDict | Словарь с заданными ключами и типами значений |
| Callable | Тип функции/метода по сигнатуре |
| strict mode (mypy) | Строгий режим: больше обязательных аннотаций и проверок |

---

## 6. Краткие упражнения (для самопроверки теории)

1. Чем `Optional[str]` отличается от `str` с точки зрения типов?
2. Что делает `# type: ignore` в коде для mypy?
3. Зачем нужен `TypeVar` в generic-функциях?
4. В чём разница между номинальной и структурной типизацией?
5. Может ли программа с ошибками типов по мнению mypy успешно выполняться в Python?

**Ответы (коротко):**  
1) `Optional[str]` = `str | None` — допускается None.  
2) Отключает проверку типов для данной строки (или конкретной ошибки).  
3) Чтобы сохранить связь между типами (например, «вход и выход одного типа») и не терять точность.  
4) Номинальная — по имени типа/наследованию; структурная — по наличию полей/методов (Protocol).  
5) Да; интерпретатор не проверяет аннотации, только mypy/другие анализаторы.

---

## 7. Полезные ссылки

- **PEP 484** — Type Hints.
- **PEP 585** — Type Hinting Generics In Standard Collections (list[str] и т.д.).
- **PEP 604** — Union с `X | Y`.
- Документация [mypy](https://mypy.readthedocs.io/).
- Модуль [typing](https://docs.python.org/3/library/typing.html) в стандартной библиотеке.
